{% from 'includes/plugs.html' import create_DA_Item, create_breaks, quiz_modal, document_modal, yt_modal, code_block%}

{% macro create_ee() %}
{% call document_modal(doc_id="doc_ee_di_1", title="Lesson 1: Current", hidden_val="doc_ee_hv_1", read="doc_ee_r_1") %}
  <p class="text-muted mb-0">
    We interact with voltage and current in our daily lives. Almost everyone knows these terms and recognizes that they have something to do with electricity. 
    This lesson serves to clarify the concept of current and contextualize their meaning in circuit analysis.
  </p>
  
  <h1 class="display-4">1.1 Consider the Atom</h1>
    <p style="text-indent: 30px;">
      To fully gain a sense of intuition as to what circuits are all about, it helps to take a look into the fundamental science that is behind these circuits. If we look at the basic structure of individual atoms, we find that they consist of electrons, protons, and neutrons. The main thing we want to pay attention to is the electrons. They are positioned in shells around the electron and each shell progressively holds more electrons represented by 2n<sup>2</sup>, where n is the shell number. <br>       
    </p>

    <p style="text-indent: 30px;">
      You might be wondering if you have accidentally stumbled into a chemistry lesson, but I assure you that there is a very good reason I am telling you this information. A circuit is basically a highway that electrons can keep travelling on. Electron shells explain how electrons are able to move in this highway. You may have noticed that many wires used to conduct electricity are made out of Copper. This is because copper has a special atomic structure. Take a look at the copper atom below.
    </p>

      <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson1_1.png') }}" alt="" width="40%" height="40%">


    <p style="text-indent: 30px;">
      Notice the “29th electron” highlighted in blue. This electron is on the outermost shell, and it is the only electron on that shell. We call those electrons free electrons, since they’re furthest away from the protons in the nucleus and can be yanked away relatively easily.<sup>1</sup>
    </p>

    <p style="text-indent: 30px;">
      Now imagine that the free electron suddenly vanishes into the void. The atom is now extremely unhappy since it has more protons than electrons, so it wants another electron to make its net charge zero. Atoms, for the most part, are all selfish pricks, so naturally it is looking to steal an electron from someone. In a copper wire, this atom would be able to easily snatch an electron from its copper atom buddy to its right. Naturally it does so, and now the copper atom that just had its electron stolen is quite angry and immediately grabs the free electron of the copper atom to its right, doing the same thing as the first electron. This triggers the chain reaction further, and voilà, you technically have a current.
    </p>
    <h1 class="display-4">1.2 Current Explained</h1>
    <p style="text-indent: 30px;">
      When we want a current to actually be able to do something other than demonstrate electron robbery, we need an astronomical amount of electrons to start moving in a uniform direction. Luckily for us, atoms are very small, and a simple copper wire has plenty enough electrons for us to work with. In order to quantify this magnitude of electrons, the unit of Coulombs is used. Note that the coulomb is the unit for charge, not number of electrons. One coulomb has a charge equivalent to roughly 6.242 x 1018 electrons.
    </p>
    <p style="text-indent: 30px;">
      With all of this information, the concept of current (I) is easy to understand. It is simply a measure of how much charge is moving. One Ampere (A) of current means that there is one coulomb of charge flowing through a single point in a circuit per second.
    </p>

    <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson1_2.png') }}" alt="">

    <p style="text-indent: 30px;">
      When electrical engineering was first studied, the electron had yet to be discovered. Thus electrical current is conventionally denoted in a circuit as flowing from the positive terminal toward the negative terminal. However, electrons actually move from the negative terminal to the positive one.
    </p>

    <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson1_3.png') }}" alt="">

    <hr>
      <p>
        <sup>1</sup>The actual force of attraction between the nucleus and the outermost electron can be determined by Coulomb's Law, F = k(Q<sub>1</sub>Q<sub>2</sub>)/r<sup>2</sup>, with F in Newtons<br> 
      </p>

      <p>
        <sup>2</sup>  If you’re a smartass, you’re probably wondering why the second atom doesn’t just steal the electron from the original atom. In fact, atoms do that all the time. If you look inside a copper wire, you’ll find electrons being passed around constantly. But the electrons are being transferred so randomly that from the outside it doesn’t seem like anything is happening at all. In actual currents, there is a force that will make all the electrons move uniformly, which we will discuss later.
      </p>


{% endcall %}

{% call document_modal(doc_id="doc_ee_di_2", title="Lesson 2: Voltage", hidden_val="doc_ee_hv_2", read="doc_ee_r_2") %}
  <p class="text-muted mb-0">
    The past lesson was a discussion about what exactly currents were. But that begs the question; what is it that makes a current happen in the first place? The answer is voltage. Keeping our knowledge of current in mind, the understanding of voltage should come naturally.
  </p>

  <h1 class="display-4">2.1 Charge Difference</h1>
    <p style="text-indent: 30px;">
      Most of what we perceive as voltage in our everyday lives are actually just electrons condensed in a specific location, creating a contrast of positive and negative charge. Consider the battery. All that it is really doing is making the electrons in it  gather on its negative terminal. This force pushes the electrons through the current to the other side of the circuit, and we call that force voltage. That is, essentially, all that voltage is. Thus we arrive at the first rule of voltagery (not a real word):
    </p>
    <p style="text-indent: 30px;">
      <strong>All voltage comes from a contrast of positive and negative charges.</strong> The most voltage drop you need, the more charge you need to gather in one place.
    </p>
    <p style="text-indent: 30px;">
      In a formal sense, voltage can also be seen as simply energy, represented in coulombs. In other words, the <strong>electric potential difference</strong> between those two points. So if you spend one joule of energy moving a negative charge of one coulomb, then there is a voltage difference of one volt between the points that the charge was at before and after you moved it. The relationship between the three units are shown below:
    </p>

    <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson2_1.png') }}" alt="">

    <p style="text-indent: 30px;">
      Now that you know what voltage is, some things should come across as common sense. However, I’m still going to explicitly say them so that it will hopefully reinforce your understanding, though I doubt you need it. Here’s the second rule of voltagery:
    </p>
    <p style="text-indent: 30px;">
      <strong>Voltage is always applied ACROSS or BETWEEN two points.</strong> It wouldn’t make any sense for voltage to exist at a single point, since you don’t have any other point to compare it to, thus invalidating the concept of <em>difference.</em>
    </p>
    <p style="text-indent: 30px;">
      Keep in mind that both positive and negative terminals must be connected to the voltage source for the voltage to be applied. This is literally just common sense. If you just connect the positive or negative ends of the voltage source to the circuit, then electrons won’t be able to flow.
    </p>

    <h1 class="display-4">2.2 Voltage Source</h1>
    <p style="text-indent: 30px;">
      There are many different types of voltage sources, but they all basically do the same thing, especially <strong>Direct Current</strong> voltage sources. Direct Current circuits and <strong>Alternating Current</strong> circuits are different things, but for now just know that in a DC circuit, the current only flows in one direction, and in an AC circuit the current changes directions.
    </p>
    <p style="text-indent: 30px;">
      Voltage sources create an electromotive force that causes the flow of charge in a circuit. A voltage source that you are probably familiar with is the battery. Shown below is what the inside of a non rechargeable primary cell looks like:
    </p>
    <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson2_2.png') }}" alt="">
    <p style="text-indent: 30px;">
      Essentially what goes on in this battery is a chemical reaction that causes the electrons from the components inside the battery to gather on the negative end of the battery. Note that the size of a battery does not determine how much voltage can be formed across the two terminals, but the <strong>ampere-hour (Ah)</strong> rating, which is how long it can last. This makes sense because the greater the battery, the more chemical reactions can happen inside the battery before the usable chemicals are depleted.
    </p>


    <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson2_3.png') }}" alt="">

{% endcall %}

{% call document_modal(doc_id="doc_ee_di_3", title="Lesson 3: Conductance", hidden_val="doc_ee_hv_3", read="doc_ee_r_3") %}
  <p class="text-muted mb-0">
    The past lesson was a discussion about what exactly currents were. But that begs the question; what is it that makes a current happen in the first place? The answer is voltage. Keeping our knowledge of current in mind, the understanding of voltage should come naturally.
  </p>

  <h1 class="display-4">3.1 Conductors vs Insulators</h1>
  <p style="text-indent: 30px;">
   <strong>Conductors</strong> are things that have a high level of conductance (woohoo, circular definition). All that means is that they allow electrons to flow through them relatively easily, so not much voltage needs to be applied across a conductor to get a current flowing. As we did in Lesson 1, let’s use copper as an example. I explained before how copper is commonly used in circuits because of its atomic structure that allows the outermost electron to be easily transferred to other atoms. This is a demonstration of a material having high conductance, since it takes less energy to transfer that outermost electron that a copper atom has. Thus good conductors are like copper and usually have one valence electron.
  </p>

  <p style="text-indent: 30px;">
    <strong>Insulators</strong>, on the other hand, are the exact opposite of conductors. They have very few free electrons and need a large amount of applied voltage for electrons to be able to move in it. If you pick up the charging cable for your phone, chances are, the cord is covered in rubber. This is to prevent the current that passes inside the cable to “leak out” if the conductor inside touches something it shouldn’t, say, your skin.<sup>1</sup>
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson3_1.png') }}" alt="">

  <h1 class="display-4">3.2 Semiconductors</h1>
  <p style="text-indent: 30px;">
    Semiconductors, as the name implies, are things that are able to be both insulators and conductors, and typically have 4 valence electrons. They are the backbone of the electronics industry, used in almost everything that contains an integrated circuit (IC). You may have heard of a semiconductor named Silicon (Si), which was so important that they named Silicon Valley, the tech hotspot of the world, after it. More on semiconductors later.
  </p>
  <hr>
  <p style="text-indent: 30px;">
    <sup>1</sup>Newsflash: electricity is extremely dangerous. Even a small amount of current is able to send you into a hell of excruciating pain. I shouldn’t need to say this, but please be careful around exposed electrical circuits, especially when water is around.
  </p>

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_4", title="Lesson 4: Ammeters & Voltmeters", hidden_val="doc_ee_hv_4", read="doc_ee_r_4") %}
  <p class="text-muted mb-0">
    In a circuit, the two major things that change in value are voltage and current. In the real world, when electrical circuits are being designed, we need a tool to measure these two variables. Ammeters and Voltmeters help us do just that.  </p>

  <h1 class="display-4">4.1 Ammeters</h1>
  <p style="text-indent: 30px;">
    <strong>Ammeters</strong>  are what’s used to measure current. In terms of measuring currents of a lower magnitude, <strong>milliammeters</strong>  or <strong>microammeters</strong>  can be used. To use an ammeter, connect it like so:
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson4_1.png') }}" alt="">

  <p style="text-indent: 30px;">
    You must connect the meter in the circuit itself because in order to measure current it needs all of the current to flow through the actual ammeter.
  </p>



  <h1 class="display-4">4.2 Voltmeters</h1>
  <p style="text-indent: 30px;">
    Voltmeters measure applied voltage across two points. To use a voltmeter, connect it to the circuit like so:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson4_2.png') }}" alt="">
  <p style="text-indent: 30px;">
    The difference in application of the voltmeter to the ammeter is that it cannot be put directly through the current, since then the meter can’t detect which distinct points in the circuit you want it to measure voltage across. Note that if you place the positive end of the voltmeter on the negative end of the circuit and vice versa, your voltage reading will simply turn out negative, since a rise in voltage is equal to a negative drop in voltage of the same magnitude.
  </p>

  <h1 class="display-4">4.3 Multimeters</h1>
  <p style="text-indent: 30px;">
    Normally it isn’t necessary to carry around both an ammeter and voltmeter, since multimeters exist. They can have a wide variety of functionality, measuring more than just current and voltage. They usually look something like this:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson4_3.png') }}" alt="">
  <p style="text-indent: 30px;">
    The one above is a digital multimeter, which displays it’s readings on an LCD panel. Analog multimeters also exist, which has its advantages. Their display looks like this:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson4_4.png') }}" alt="">
  <p style="text-indent: 30px;">
    This pointer indicator display enables people to memorize the general area where the pointer is when they take a measurement, so then they can sense if something is wrong immediately instead of comparing numbers. It also allows for real time tracking of the measurement being taken, so you can see how the value is changing.
  </p>

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_5", title="Lesson 5: Resistance (Part 1)", hidden_val="doc_ee_hv_5", read="doc_ee_r_5") %}
  <p class="text-muted mb-0">
    We now know what current and voltage are, but we still don’t know how to control current. If you just attach a copper wire to the positive and negative ends of a battery, electrons would run through the wire instantly. That is extremely dangerous, as the electric potential energy has no way of being dispersed and ends up being exerted as heat. Basically, the wire would spontaneously combust. Evidently your electronics aren’t exploding left and right, and you can thank resistors for that.
  </p>

  <h1 class="display-4">5.1 Resistor Basics</h1>
  <p style="text-indent: 30px;">
    Resistors are usually represented in a circuit with the symbol below:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_1.png') }}" alt="">
  <p style="text-indent: 30px;">
    <strong>Resistors</strong>  are basically terrible conductors, which ironically makes them really helpful. We use the unit <strong>Ohms(Ω)</strong> to measure how much resistance that a resistor has. The more resistance that a resistor has, the less conductance it has, and the more it acts like an insulator. Conductance has the symbol G and is measured in <strong>Siemens (S)</strong>.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_2.png') }}" alt="">
  <p style="text-indent: 30px;">
    How much resistance a resistor has can be determined by its material, length, cross-sectional area, and temperature of the material. We’ve already gone over why the material of an object affects its resistance. What’s interesting is that free electrons pass more easily through resistors with larger cross-sectional areas. Temperature also plays a part in an object’s conductivity, as when there is more energy, resistor particles start jiggling about and making it hard for electrons to flow through the resistor as easily.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_3.png') }}" alt="">
  <p style="text-indent: 30px;">
    As shown above, the Greek letter Rho (⍴) represents the resistivity of the material, while l is the length of the resistor and A is the cross-sectional area of the resistor, measured in Circular Mils (CM). The Mil  and circular mil is defined by:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_4.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_5.png') }}" alt="">
  <p style="text-indent: 30px;">
    This makes it so that the Circular Mil can simply be measured by squaring the diameter of a circular shape, as shown below:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_6.png') }}" alt="">
  <p style="text-indent: 30px;">
    The standardization of size for wires is done through Wire Tables such as American Wire Gage (AWG) sizes.
  </p>

  <h1 class="display-4">5.2 How Temperature Impacts Conductance</h1>
  <p style="text-indent: 30px;">
    An increase in temperature generally doesn’t impact how many free electrons that a <strong>conductor</strong> has. However, it does increase the movement of the particles, making current harder to flow. Thus, temperature is positively correlated with resistance in conductors.
  </p>
  <p style="text-indent: 30px;">
    <strong>Semiconductors</strong>  and <strong>insulators</strong>  get more free electrons when heated up, so temperature is negatively correlated with resistance in semiconductors and insulators.
  </p>
  <p style="text-indent: 30px;">
    Conductance at different temperatures can also be calculated using the <strong>temperature coefficient of resistance</strong>, defined by the below equation, where absolute value of T<sub>i</sub> is the inferred absolute temperature of the material, an attribute that varies depending on the material.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_7.png') }}" alt="">
  <p style="text-indent: 30px;">
    The resistance R1 at temperature T<sub>1</sub> can then be determined by
  </p>
  <img src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_8.png') }}" alt="">
  <p style="text-indent: 30px;">
    Which can also be written in derivative form as such:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_9.png') }}" alt="">

  <h1 class="display-4">5.3 Ohmmeters</h1>
  <p style="text-indent: 30px;">
    Just like the voltmeter or ammeter, the ohmmeter measures resistance and can be built into a multimeter. However, there are several key differences that you need to pay attention to when using an ohmmeter.
  </p>
  <p style="text-indent: 30px;">
    The ohmmeter is used to measure resistance across two points, so you attach it to a circuit similar to a voltmeter, like shown below. Since it doesn’t care about what is between the two leads, you can measure the combined resistance of multiple circuit elements with an ohmmeter.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_10.png') }}" alt="">
  <p style="text-indent: 30px;">
    One rule you absolutely must follow when using an ohmmeter is to <em>never attach it across an energized component</em>. This is because the way that an ohmmeter works is by passing a small sensing current through the leads and seeing how much resistance there is between the leads. If there is another current passing through the resistor and the ohmmeter, it would be impossible to tell how much resistance there is.
  </p>
  <p style="text-indent: 30px;">
    Another thing to know is that you shouldn’t leave a multimeter on the ohmmeter mode and have the two leads touch, since the sensing current would drain the multimeter’s battery.
  </p>

  <h1 class="display-4">5.4 Determining Rho</h1>
  <p style="text-indent: 30px;">
    The resistivity of a material is determined using a 1cm3 square as a sample. The value of resistivity is then measured in Ω-cm using metric units. The derivation of units is also shown below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_11.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_12.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson5_13.png') }}" alt="">

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_6", title="Lesson 6: Resistance (Part 2)", hidden_val="doc_ee_hv_6", read="doc_ee_r_6") %}
  <p class="text-muted mb-0">
    While the last section covers the theoretical and conceptual ideas involving resistors, we still need to know how to use resistors in real life. In this short section we go over the two types of resistors and how to read resistance values. Resistors come in many forms, but for the sake of simplicity let’s just think of resistors as the commonly-found film resistors.  </p>
  <h1 class="display-4">6.1 Resistor Traits</h1>
  <p style="text-indent: 30px;">
    There are a few characteristics of resistors that we haven’t yet covered. The <strong>wattage</strong>  rating of a resistor determines how much current can be run through the resistor and have it not blow up due to overheating. Generally, the bigger the resistor, the higher the wattage rating. However, the resistance level of a resistor is also determined by its material, not only its size.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson6_1.png') }}" alt="">
  <p style="text-indent: 30px;">
    Resistors also have a <strong>maximum voltage rating</strong>. Since resistors can have different internal materials that affect their resistance, resistors that have the same wattage rating can have different resistance levels. Furthermore, the higher the resistance, the more voltage you have to apply across it to reach the same wattage dissipation. Thus, when voltage is overapplied, even though the resistor won’t overheat, the high voltage will start forcing current through it, causing the resistor to break down.
  </p>
  <p style="text-indent: 30px;">
    Resistors can also be either <strong>fixed</strong> or <strong>variable</strong> resistors. <strong>Fixed resistors</strong> have two terminals and have a fixed resistance. <strong>Variable resistors</strong>, also known as rheostats, can have either 2 or 3 terminals and have a resistance value that can be changed. If it has 3 terminals, then it is called a <strong>potentiometer</strong>, since it controls potential levels.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson6_2.png') }}" alt="">

  <p style="text-indent: 30px;">
    The resistance value of a potentiometer is determined by the highest resistance across the potentiometer, which is usually the first and last terminal. As shown below, the potentiometer is rated at 1 MΩ, which is the most amount of resistance you can get out of the potentiometer.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson6_3.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson6_4.png') }}" alt="">

  <h1 class="display-4">6.2 Reading Resistor Valuesa</h1>
  <p style="text-indent: 30px;">
    For resistors that are too small to have their resistance value imprinted on them, we use 4 to 6 bands of color coding to make reading their resistance value possible without using microscopic text. It would look something like this:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson6_5.png') }}" alt="">
  <p style="text-indent: 30px;">
    For 4-band color schemes, the bands are read from the end with bands clumped closer to the resistor’s terminal. The first and second band represent the first and second digits of the resistor’s resistance value. The third band is the power-of-ten multiplier of resistor values. For example, if the third band has a color value of 2 and the first two bands represent 14, then the resistor has a resistance of 1400. The fourth band represents the precision or tolerance of the resistor. The color table is shown below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson6_6.png') }}" alt="">
  <p style="text-indent: 30px;">
    For five-band color coded resistors, the third band is simply the third digit of resistance, while the fourth becomes the multiplier and the fifth one becomes the tolerance. If there is a 6th band, the only difference is that the 6th band represents the temperature coefficient of the resistor.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson6_7.png') }}" alt="">
{% endcall%}

{% call document_modal(doc_id="doc_ee_di_7", title="Lesson 7: Resistors (Part 3)", hidden_val="doc_ee_hv_7", read="doc_ee_r_7") %}
  <p class="text-muted mb-0">
    There are a few other more interesting components that deal with resistance that we haven’t covered. They make electronics able to manage resistance in a more complex way, since many of them have resistance values dependent on another environment factor.
  </p>
  <h1 class="display-4">7.1 Memristors</h1>
  <p style="text-indent: 30px;">
    For a bit of background, the memristor is a relatively new development in the field of electrical engineering. It was first postulated by professor Leon Chua of University of California at Berkeley in 1971. It was not until 2008 that researchers led by Dr. Stanley Williams (a.k.a the bleached version of Jeff Ross, shown below) at Hewlett Packard Laboratories announced that they had successfully created a memristor.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_1.png') }}" alt="">

  <p style="text-indent: 30px;">
    A memristor, or memory resistor, is a resistor with a changeable resistance value that will stay the same after being altered. To increase a memristor’s resistance value, the flow of charge passing through it must increase. To then decrease the memristor’s resistance, you must have an increasing charge flowing in the opposite direction.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_2.png') }}" alt="" width="40%" height="40%">

  <p style="text-indent: 30px;">
    I can already feel your confusion as to what you have just read, so let me explain to the best of my abilities. Textbooks normally describe memristors using the water pipe analogy, which is how professor Robert L. Boylestad does it in Introductory Circuit Analysis. However, as much as I love that book, I didn’t feel as if this analogy made much sense, and to be honest, the scientific explanation straight up made more sense to me. So I’m just going to explain memristors using scientific terms and hope that it makes sense to you as well.
  </p>

  <p style="text-indent: 30px;">
    Memristivity was accomplished by HP Labs mainly by using titanium dioxide (TiO2), which by itself has a high level of resistance and a low level of conductance. However, when you dope TiO2 with something else you can make it a very conductive material. So the construction of a memristor is quite simple. You just split the memristor into two parts; one with doped TiO2 to become oxygen-deficient titanium oxide (TiO2-x) that has high conductance, and one side with pure TiO2 that has high resistance. If you pass current through the side with the doped TiO2, the dopants will start invading the pure TiO2 and making it doped, thus lowering the resistance of the whole memristor. The bigger the current, the more TiO2 the dopant can shift, thus the more conductive the memristor. When you stop increasing the flow of charge through the memristor, the resistance of the memristor remains the same, which is where its name as a memory resistor comes from.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_3.png') }}" alt="">

  <p style="text-indent: 30px;">
    The real magic happens when you pass a negative current (current flowing the opposite direction) through the memristor. The doping process is reversed, and the amount of pure TiO2 increases, thus letting the memristor regain its resistance.
  </p>

  <p style="text-indent: 30px;">
    The reason why memristors are tremendously important is their ability to act as a form of information storage. Since the physical nature of memristors causes them to have low decay and high endurance while retaining information, you can apply them in electronics that are constantly switched on and off. An easy example would be your computer. Boot times could theoretically be eliminated using memristors, since they would remember the state they were in when you powered off your computer and would instantly function with the same properties when you power your computer back on again.
  </p>

  <h1 class="display-4">7.2 Superconductors</h1>
  <p style="text-indent: 30px;">
    Although we disregard the resistance of a lot of things when talking about theoretical circuit analysis, almost everything has at least some level of resistance. Even copper wire, which is one of the best conductors for electric current, still has a resistivity of 0.0171 Ohm x mm2/m. A <strong>superconductor</strong>, however, has effectively zero resistance. The basis of superconductivity is the <strong>Cooper effect</strong>, in which electrons travel in pairs to help each other maintain peak velocity somehow.
  </p>
  <p style="text-indent: 30px;">
    As the temperature increases, superconductivity becomes increasingly hard to maintain. The history of superconductivity development is basically researchers playing a game of “who can make a superconductor with the highest critical temperature”. Here’s a helpful graph that visualizes it:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_4.png') }}" alt="">
  <p style="text-indent: 30px;">
    As the temperature of superconductors increase, it becomes easier to use them, as they don’t need as much help being cooled down below their critical temperature. They can be applied to increase the speed of charged particles, creating ridiculously powerful electromagnets, which is utilized by things such as MRI imaging and maglev trains.
  </p>

  <h1 class="display-4">7.3 Thermistors</h1>
  <p style="text-indent: 30px;">
    <strong>Thermistors</strong> are resistors whose resistance value is affected by its temperature, which can be either due to internal heating or externally caused. The graph below shows the resistance as a function of temperature for thermistors. The symbol for thermistors is also shown. Thermistors can have a negative temperature coefficient (where as temperature increases resistance decreases) or positive temperature coefficient (where as temperature increases resistance increases).
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_5.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_8.png') }}" alt="">

  <h1 class="display-4">7.4 Photoconductive Cells</h1>
  <p style="text-indent: 30px;">
    For photoconductive cells, their resistance is determined by the intensity of light it is exposed to. Photoconductors have a negative illumination coefficient, so as intensity increases, resistance decreases.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_7.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_9.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_10.png') }}" alt="">

  <h1 class="display-4">7.5 Varistors</h1>
  <p style="text-indent: 30px;">
    Varistors are resistors that vary in resistance level with the amount of voltage applied across it. It has a set boundary of voltage that can be applied across it. They function as a voltage surge protector, as when the voltage gets too high past a certain level they will start to conduct. A possible current to voltage graph of a varistor is shown below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_11.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson7_12.png') }}" alt="">

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_8", title="Lesson 8: Ohm's Law", hidden_val="doc_ee_hv_8", read="doc_ee_r_8") %}
  <p class="text-muted mb-0">
    Ohm’s law is an equation that mathematically relates the three fundamental values of electronic circuitry: resistance, voltage, and current. It is one of the most important equations in circuit analysis, and luckily it is also one of the simplest.
  </p>

  <h1 class="display-4">8.1 Ohm's Law</h1>
  <p style="text-indent: 30px;">
    Ohm’s Law, named after George Simon Ohm, is represented as I =VR or any other form of the same mathematical expression. This is depicted using Ohm’s triangle, which is a handy way to familiarize yourself with the different forms of Ohm’s Law.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson8_1.png') }}" alt="">

  <p style="text-indent: 30px;">
    A good way to think about Ohm’s Law is to establish logic as to what the variables are actually representing. So when Ohm’s Law says I=V/R , think of it as Effect = cause/opposition. Voltage across two points is the thing making current happen, and resistance is the thing slowing down the current, and naturally the effect is how much current flows.
  </p>
  <p style="text-indent: 30px;">
    Ohm’s Law as a linear relationship between current can be shown by representing resistance in terms of current and voltage as a graph. This type of graph is known as an IV curve, and it is often used to show the properties of circuit components. The graph below shows that in a DC circuit the relationship between voltage and current for a set resistance is linear.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson8_2.png') }}" alt="">

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_9", title="Lesson 9: Power & Energy", hidden_val="doc_ee_hv_9", read="doc_ee_r_9") %}
  <p class="text-muted mb-0">
    The notion of power is the same as you would probably think it is. When you talk about the power level of a car, you are referring to how much energy the car can expend within a certain amount of time. When you have a powerful motor, it means that it can convert energy from electrical to mechanical in a short amount of time.  </p>
  <h1 class="display-4">9.1 Power</h1>
  <p style="text-indent: 30px;">
    The unit used for measuring power is the <strong>Watt</strong>, defined as
  </p>

  <img src="{{ url_for('static', filename='assets/img/courses/ee/lesson9_1.png') }}" alt="">

  <p style="text-indent: 30px;">
    The <strong>Joule</strong> is the unit for energy, so power is expressed as work done over time, since the Joule is the unit of measurement for work. Also since work in electrical systems is charge multiplied by voltage and charge over time is current, the electrical equation for power can be found to be Power = Current x Voltage, or
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson9_2.png') }}" alt="">

  <p style="text-indent: 30px;">
    This equation can also be represented by other variables using the handy Ohm’s Law. In a normal circuit, the power in the circuit needs to be dispersed somehow. If the circuit doesn’t have a component with resistance, the heat will be distributed on the wire and the voltage source, causing things to burn up. Thus we need a resistor or light bulb to disperse the power.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson9_3.png') }}" alt="">

  <p style="text-indent: 30px;">
    There is a confusing convention in electrical engineering where the abbreviation for energy (W) and watt (W) are very similar. The only distinction is that the notation for energy is in italics, since it is a variable. Watts is not in italics since it is a unit.
  </p>

  <h1 class="display-4">9.2 Energy</h1>
  <p style="text-indent: 30px;">
    As introduced in the previous section, energy can be expressed with time and power, as energy (W) can be determined by
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson9_4.png') }}" alt="">

  <p style="text-indent: 30px;">
    This makes sense because to maintain a power level for a longer period of time, you would need more energy. Energy can also scale with larger units such as the watthour (Wh) and kilowatthour (kWh), defined as
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson9_5.png') }}" alt="">

  <p style="text-indent: 30px;">
    When energy is entered into a system, there is always a certain amount of energy that is lost or stored by the system before it outputs it. The same applies to power. When considering the efficiency of a system, we simply evaluate how much of the power a system can output given a certain input. Efficiency, denoted by eta (η), can be found using the equation
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson9_6.png') }}" alt="">

  <p style="text-indent: 30px;">
    Since power output can’t be larger than the power input, the maximum efficiency possible is 100 percent. When you have multiple components, multiply the efficiencies of each component to get the total efficiency.
  </p>

  <h1 class="display-4">9.3 Fuses</h1>
  <p style="text-indent: 30px;">
    Fuses and circuit breakers are used to limit the amount of power drawn. You are probably familiar with circuit breakers, as they are present in almost every building you walk into. When you use too many appliances at once, causing the power draw to exceed the rated power value of a circuit breaker, it will trip, cutting out the power.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson9_7.png') }}" alt="">

  <p style="text-indent: 30px;">
	  A fuse functions the same way a circuit breaker does, but instead of tripping a switch when it is overloaded, they just self-destruct. They have a metallic conductor in the middle, which melts when the current is too high, thus breaking the circuit.
  </p>

  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson9_8.png') }}" alt="">

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_10", title="Lesson 10: Series Resistors", hidden_val="doc_ee_hv_10", read="doc_ee_r_10") %}
  <p class="text-muted mb-0">
    As stated before, circuits are simply paths for electricity to flow. These paths can then be manipulated to make different circuit patterns. There are two types of current, alternating (AC) or direct (DC) currents. We mainly look at DC currents, which have just constant flow of charge in one direction.
  </p>

  <h1 class="display-4">10.1 Equivalent Resistors</h1>
  <p style="text-indent: 30px;">
    Fixed resistors are two-terminal devices since they have two places that you can connect to a circuit with. When you line them up next to each other, it means that you’ve made resistors that have been connected in series. An example of series resistors are shown below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson10_1.png') }}" alt="">

  <p style="text-indent: 30px;">
    When evaluating resistor configurations, we use the method of simplification, which means that we take a part of the circuit containing series and we represent it as one resistor that is equivalent in nature to that of all the resistors in that part of the circuit. The image below shows the given circuit (a) and the simplified version of the circuit (b).
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson10_2.png') }}" alt="">


  <h1 class="display-4">10.2 Calculating Resistance</h1>
  <p style="text-indent: 30px;">
    The equivalent resistance of resistors in series are fairly easy to calculate. You simply add all the resistors’ resistance values together to get the equivalent resistance value for those series resistors. So the more resistors you add on into the series, the greater the resultant resistance will be, and it doesn’t matter how the resistors are ordered.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson10_3.png') }}" alt="">

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_11", title="Lesson 11: Series Circuits", hidden_val="doc_ee_hv_11", read="doc_ee_r_11") %}
  <p class="text-muted mb-0">
    Now that we’ve seen how resistors behave in series circuits, we can analyze the other components in the circuit to gain a holistic view as to how a series circuit functions. Since we are only discussing DC currents, it is important to note that the current will not change in a circuit as long as both terminals of the battery are connected to the circuit.  </p>
  <h1 class="display-4">11.1 Current in Series Circuits</h1>
  <p style="text-indent: 30px;">
    When talking about circuits, you have to keep the concept of current in mind. A quick review from the first lesson in this course: the direction of conventional current in a dc circuit is from the positive end of the current source’s terminal and into the negative terminal. In a DC series circuit, the current is the same at every point. This current level can be found using Ohm’s law, since the resistor in the series circuit as a whole can be represented with one equivalent resistor. E, denoted below, is electromotive force.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_1.png') }}" alt="">

  <h1 class="display-4">11.2 Voltage in Series Circuits</h1>
  <p style="text-indent: 30px;">
    Hopefully you haven’t forgotten this already, but voltage is the driver behind the movement of charge that defines current. Since voltage has a nature of making electrons go from a positive end to a negative end, to have voltage across anything you need polarity. For resistors, the polarity of voltage across is determined by the direction of the current. Conventional current always enters the resistance from the positive side. A few examples are shown below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_2.png') }}" alt="">


  <p style="text-indent: 30px;">
    Similar to how Ohm’s law was applied to find current if resistance and voltage was given, Voltage across a resistor can be found if you multiply its resistance value with the current flowing through it.
  </p>
  <p style="text-indent: 30px;">
    You may be wondering how to consider the voltage drop across a specific resistor in a series circuit with multiple resistors. In general, the larger the resistance, the larger the voltage is across the resistor, since it dissipates more power.
  </p>
  <p style="text-indent: 30px;">
    You can also use the <strong>Ratio Rule</strong>, which states that the ratio of the voltages across the resistor is directly proportionate to the ratio of their resistance values. Using the example below, the ratio rule is shown.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_3.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_4.png') }}" alt="">
  <p style="text-indent: 30px;">
    The <strong>Voltage Divider Rule (VDR)</strong> is an alternative method. It basically involves representing voltage across the resistors as different forms of Ohm’s law, and then substituting values. An example of VDR being applied is shown below, with the resulting variable representation for each voltage value.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_5.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_6.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_7.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_8.png') }}" alt="">
  <p style="text-indent: 30px;">
    Thus, applying VDR tells us that the voltage across a resistor in a series circuit is the resistance of the resistor multiplied by the total applied voltage over the total resistance of the series circuit. Notice how this is basically an application of the ratio rule, in which the reference ratio is from the whole circuit.
  </p>
  <h1 class="display-4">11.3 Power Distribution in a Series Circuit</h1>
  <p style="text-indent: 30px;">
    As common sense would tell you, and as we’ve learned before, the power that goes into something must equal the power dissipated. The same applies to series circuits. The power, in watts, delivered by the supply is dissipated by the resistors as heat. Below is an example of such.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_9.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_10.png') }}" alt="">
  <p style="text-indent: 30px;">
    The power dissipated can also be calculated using one of the formulas that we learned before, which could be any of the following forms:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson11_11.png') }}" alt="">
  <p style="text-indent: 30px;">
    From the equation P = I<sup>2</sup>R you can derive that the resistor with the most resistance takes the burden of dissipating the most amount of power in a series circuit, since current is always constant.
  </p>
{% endcall%}

{% call document_modal(doc_id="doc_ee_di_12", title="Lesson 12: Kirchhoff's Voltage Law", hidden_val="doc_ee_hv_12", read="doc_ee_r_12") %}
  <p class="text-muted mb-0">
    Kirchhoff’s Voltage Law, named after Gustav Robert Kirchhoff, is another one of the cornerstones of electrical engineering, and like Ohm’s Law, it is not that difficult to understand as long as you have a half-decent grasp of what voltage is.  </p>
  <h1 class="display-4">12.1 Voltage Sources in Series</h1>
  <p style="text-indent: 30px;">
    Similar to how resistors can be put in series, you can also put voltage sources in series. The similarities further in that you can simply multiple voltage sources into one equivalent voltage source. An example you’ve probably observed before is your flashlight battery. Life the one shown below, inserting two batteries head to toe doubles the voltage it applies across the whole flashlight.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson12_1.png') }}" alt="">
  <p style="text-indent: 30px;">
    If you use a calculator with four batteries and wonder why every other battery needs to face another way, the schematic is shown below, along with the equivalent voltage source. They actually connect head to toe in a snakelike pattern.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson12_2.png') }}" alt="">


  <h1 class="display-4">12.2 Kirchhoff's Voltage Law</h1>
  <p style="text-indent: 30px;">
    Before we can discuss <strong>Kirchhoff’s Voltage Law</strong>, or KVL, we must first discuss the concepts of <strong>closed loops</strong> and <strong>voltage drops and voltage rises</strong>.
  </p>
  <p style="text-indent: 30px;">
    A closed loop in circuit analysis is any path that allows charge to come back to its original starting place. A series circuit by itself is an example of a closed loop, as the current source is both the beginning of the circuit and the end of the circuit.
  </p>
  <p style="text-indent: 30px;">
    A voltage rise refers to where voltage across two points is increased, and a voltage drop refers to where voltage across two points is decreased. These concepts are astoundingly straightforward, and they function very algebraically (meaning you can add and subtract them how you would for normal numbers). A battery would be a voltage rise, and a resistance would be a voltage drop.
  </p>
  <p style="text-indent: 30px;">
    Kirchhoff’s voltage law states that the sum of the rises and drops on a closed loop is zero. Symbolically, it is represented as
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson12_3.png') }}" alt="">
  <p style="text-indent: 30px;">
    Although KVL is quite confusing at first glance, it makes a lot of sense when you think about it. In a closed loop, the voltage ramped up from one end of the voltage source needs to be ramped back down when it reaches the other end of the voltage source in order to maintain electric potential levels. When you stick a wire to a positive and negative end of a battery, you make a closed loop that does not adhere to this rule, as there is no voltage drop. Therefore something is guaranteed to explode if you leave the circuit active long enough. Here’s a diagram showing KVL.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson12_4.png') }}" alt="">
  <p style="text-indent: 30px;">
    KVL can be used in calculations where you are asked to find the voltage drop across two points given the rest of the closed loop’s voltage rises and drops.
  </p>
  <hr>
  <p style="text-indent: 30px;">
    <sup>1</sup>The direction of the voltage drop or voltage rise is entirely arbitrary as long as it is consistent within a circuit. If you want the resistor to be a voltage rise, then the battery will be a voltage drop.
  </p>
{% endcall%}

{% call document_modal(doc_id="doc_ee_di_13", title="Lesson 13: Kirchhoff's Current Law", hidden_val="doc_ee_hv_13", read="doc_ee_r_13") %}
  <p class="text-muted mb-0">
    Kirchhoff’s Current Law is another one of the simple laws that appeals greatly to common sense. The point of this lesson is just to establish terminology, as the concepts are very straightforward.
  </p>

  <h1 class="display-4">13.1 Nodes</h1>
  <p style="text-indent: 30px;">
    <strong>Nodes</strong> are defined in electrical engineering as a junction of two or more circuit elements. This basically refers to any point on a closed circuit, since electricity needs to be flowing from one place to another in that instance. Note that in schematics, a single node can be disguised as an array of many connections, as shown below:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson13_1.png') }}" alt="">

  <h1 class="display-4">13.2 Kirchhoff's Current Law</h1>
  <p style="text-indent: 30px;">
    <strong>Krichhoff’s Current Law</strong> states that the sum of the currents entering a circuit or circuit components is equal to the sum of the currents leaving that area. KCL is just a fancy way of saying current is conserved in a system, and whatever enters the system is going to equal to whatever comes out. Here is the equation form of KCL:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson13_2.png') }}" alt="">
  <p style="text-indent: 30px;">
    A demonstration of KCL using part of a circuit is shown below. Note that direction of the currents show whether they are entering the system of exiting:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson13_3.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson13_4.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson13_5.png') }}" alt="">
  <p style="text-indent: 30px;">
    KCL can be useful in instances where you don’t know what the components of the system are and are only given some inputs and outputs. You can treat the entire system as a single node, making calculations much more intuitive.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson13_6.png') }}" alt="">

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_14", title="Lesson 14: Ground", hidden_val="doc_ee_hv_14", read="doc_ee_r_14") %}
  <p class="text-muted mb-0">
    Remember how voltage can only be applied across two points? Well, if you want to talk about voltage at a single point, there has to be a relative point where you can compare the voltage difference with. Setting a point called a “ground” in the circuit allows you to do that.
  </p>

  <h1 class="display-4">14.1 Setting Ground</h1>
  <p style="text-indent: 30px;">
    We set a ground usually at a point near the voltage source, to ensure that its defined potential level is zero volts. Usually ground is denoted by the symbol below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson14_1.png') }}" alt="">
  <p style="text-indent: 30px;">
    When there are two ground symbols with no connection on the schematic, just assume that it is connected and there is no voltage drop or rise between them. An example is shown below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson14_2.png') }}" alt="">
  <p style="text-indent: 30px;">
    Sometimes, ground will be placed in a place where there is voltage change between ground and the voltage source, in which case the relative voltage of points on that circuit will be different. It will not, however, impact the magnitude or polarity of the voltage across any element or elements. Any relative voltage less than ground will be negative, and any voltage greater than ground will be positive.
  </p>

  <h1 class="display-4">14.2 Single vs Double Subscript Notation</h1>
  <p style="text-indent: 30px;">
    When referring to voltage, you might see either a single or double subscript notation, or voltage subscripts that specify the potential difference across two points. An example, Vab is shown below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson14_3.png') }}" alt="">
  <p style="text-indent: 30px;">
    In double subscript notation, the letter that comes first always refers to the point with higher electric potential that the other. If the second letter has a higher potential difference, then you must add a negative sign in front of the notation.
  </p>
  <p style="text-indent: 30px;">
    The single-subscript notation is another way of representing voltages, except there is no second point of comparison. You simply compare the point to ground, which is at a relative zero volts. An example of single-subscript, Va and Vb is used below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson14_4.png') }}" alt="">
  <p style="text-indent: 30px;">
    Voltage in double notation can be represented with single notation using the equation below, as long as both single notation reference points have the same ground:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson14_5.png') }}" alt="">

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_15", title="Lesson 15: Parallel Resistors", hidden_val="doc_ee_hv_15", read="doc_ee_r_15") %}
  <p class="text-muted mb-0">
    Aside from the series configuration, there is another main network configuration for circuits. Circuit components can be put in a configuration in which they are parallel to one another to make a parallel circuit. This lesson covers how resistors behave when put in parallel.
  </p>

  <h1 class="display-4">15.1 Schematics</h1>
  <p style="text-indent: 30px;">
    Circuit elements or branches are defined to be in parallel when they have two common points of conjunction. There may be more than one parallel component, and they may also be represented differently on a schematic, but they all mean parallel circuits. A few examples using only resistors are shown below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson15_1.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson15_2.png') }}" alt="">

  <h1 class="display-4">15.2 Calculations</h1>
  <p style="text-indent: 30px;">
    The total/equivalent resistance of N amount of resistors in parallel is shown below, including an example schematic.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson15_3.png') }}" alt="">
  <p style="text-indent: 30px;">
    Or
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson15_4.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson15_5.png') }}" alt="">
  <p style="text-indent: 30px;">
    There are a few things to note here. You may have noticed that when you add more resistors, the resistance always decreases. That is true because in parallel circuits you are giving more paths for the current to flow, thus increasing the current. We know from Ohm’s law that when current increases, either the voltage has to increase or the resistance has to decrease. Since the voltage is the same, the resistance decreases. Thus, the total resistance of parallel resistors is always going to be less than the value of the smallest resistors in parallel. If you add more resistors in parallel, the total resistance of the parallel resistors is going to drop.
  </p>
  <p style="text-indent: 30px;">
    Also, if you have a very large resistor in parallel with a very small resistor, the total resistance ends up being slightly less than the smaller resistor. This is due to the fact that very little current flows through the path with the larger resistor, so the resistance is largely similar to that of the smaller resistor.
  </p>
  <p style="text-indent: 30px;">
    Following the equation given for parallel resistors, if you have N amount of resistors in parallel, you can simply use the equation
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson15_6.png') }}" alt="">

  <h1 class="display-4">15.3 Current Divider Rule</h1>
  <p style="text-indent: 30px;">

    The <strong>current divider rule (CDR)</strong> is a method for finding the current through a resistor in a parallel circuit. The premise of CDR follows the general idea that current will always seek the path of least resistance, and thus the smaller the resistance of the branch, the more current will flow through that branch. Kirchhoff’s Current Law applies, so the sum of the currents in each branch is equal to the current flowing in the parallel circuit.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson15_7.png') }}" alt="">
  <p style="text-indent: 30px;">
    The ratio rule from when we talked about with series resistors will also be applicable here.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson15_8.png') }}" alt="">
  <p style="text-indent: 30px;">
    You can also use the total resistance and total current as a ratio to solve for individual current flow.
  </p>
{% endcall%}

{% call document_modal(doc_id="doc_ee_di_16", title="Lesson 16: Parallel Circuits", hidden_val="doc_ee_hv_16", read="doc_ee_r_16") %}
  <p class="text-muted mb-0">
    The approach to understanding parallel circuits is similar to that of series circuits. We first look at a specific component’s behavior to get an idea as to how the circuit configuration functions, then look at other aspects of the circuit.
  </p>

  <h1 class="display-4">16.1 Voltage and Current in Parallel Circuits</h1>
  <p style="text-indent: 30px;">
    The voltage across circuit elements in parallel is always going to be the same. If you think of voltage as pressure, the pressure difference across two points is always going to be the same regardless of how many paths there are between those two points. This is demonstrated in the diagram below.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_1.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_2.png') }}" alt="">
  <p style="text-indent: 30px;">
    Current entering circuit elements in parallel can be found using Ohm’s law by viewing the total resistance of the elements in the parallel circuit as one single resistor:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_3.png') }}" alt="">
  <p style="text-indent: 30px;">
    Note that this is NOT the current that flows through the individual circuit components, since the current is split up before entering the components in a parallel circuit. To find the current through each individual component, use Ohm’s law for each individual component:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_4.png') }}" alt="">
  <p style="text-indent: 30px;">
    Since the current is split up in a parallel circuit and current doesn’t just magically disappear, we can postulate that the sum of the currents flowing through each component is equal to the current coming out the current source:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_4.png') }}" alt="">
  <p style="text-indent: 30px;">
    This works out mathematically, since we learned in the last lesson that
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_5.png') }}" alt="">
  <p style="text-indent: 30px;">
    After some quick maths you find that
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_6.png') }}" alt=""> <br>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_7.png') }}" alt="">
  <p style="text-indent: 30px;">
    Then substitute with Ohm’s law, and you get
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_8.png') }}" alt="">
  <p style="text-indent: 30px;">
    An interesting observation is that the behavior of voltage and current in series and parallel resistors are the inverse; for a parallel circuit, the source current is the sum of the current in the branches, while in a series circuit, the applied voltage equals the sum of the voltage drops throughout the circuit. This diagram demonstrates that pretty well.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_9.png') }}" alt="">


  <h1 class="display-4">16.2 Power in Parallel Circuits</h1>
  <p style="text-indent: 30px;">
    Power is fairly easy to understand, as we know that Power (P) = Voltage (V) x Current (I). Thus, The power supplied to the circuit is the sum of the power dissipated by each circuit component, and is the exact same as in series resistors:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_10.png') }}" alt="">
  <p style="text-indent: 30px;">
    To find the power delivered to each component, just multiply the current flowing through that component by the voltage applied across it. For R1 shown above, the power it receives P1 is
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_11.png') }}" alt="">
  <p style="text-indent: 30px;">
    From this we can observe that the larger the resistor, the less power it absorbs in a parallel circuit.
  </p>

  <h1 class="display-4">16.3 Voltage Sources in Parallel</h1>
  <p style="text-indent: 30px;">
    In the real world, voltage sources such as batteries have a current rating, meaning that they can only push out so much current regardless of voltage. When you connect two voltage sources in parallel, you can have more current being supplied. A diagram depicting that is shown below, including the equivalent voltage source.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson16_12.png') }}" alt="">
  <p style="text-indent: 30px;">
    Notice that the voltage of the two voltage sources in parallel is equal to each other. This is so the sum of the voltage drops in the loop of the parallel voltage sources is zero and they do not violate Kirchhoff’s Voltage Law. Voltage sources can only be placed in parallel only if they have the same voltage.
  </p>
  <p style="text-indent: 30px;">
    If you put two batteries that don’t have the same voltage rating in parallel, the battery with the higher voltage will discharge into the battery with lower voltage, with power being dispersed only by the smaller battery’s internal resistance, which is very small. Since batteries aren’t really meant to be resistors, the battery will probably explode.
  </p>

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_17", title="Lesson 17: Open and Short Circuits", hidden_val="doc_ee_hv_17", read="doc_ee_r_17") %}
  <p class="text-muted mb-0">
    In this short lesson we clarify the concepts of open and short circuits, to make future applications of methods easier to comprehend.
  </p>

  <h1 class="display-4">17.1 Open Circuits</h1>
  <p style="text-indent: 30px;">
    An open circuit is a circuit that has two isolated terminals that are not connected. Furthermore, the current in an open circuit must be zero, but voltage is allowed to exist across the two terminals. Here is an example:
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson17_1.png') }}" alt="">
  <p style="text-indent: 30px;">
    Remember fuses? They create open circuits by burning the connection of the circuit when things get too hot. This cuts the current to zero, eliminating risk of damaging any circuit component. However, there is still voltage across the two connectors, so if you aren’t careful when removing burned out fuses, you might shock yourself by bridging the connectors.
  </p>

  <h1 class="display-4">17.2 Short Circuits</h1>
  <p style="text-indent: 30px;">
    Short Circuits are established when two ends of a voltage source are connected with a path very little to no resistance between them. A short circuit has current flowing through it, but no voltage drop or rise across its terminals. Even if a circuit has resistors, if there is one path that has no resistance, the circuit will still be shorted, since current always chooses to go the path of least resistance. An example is shown below. We know from Ohm’s law that when resistance is very small, current will get very large with the same voltage drop. Luckily, our example depicts the circuit having a fuse, which burns up when there is too much current, thus preventing anything from overloading on current and exploding.
  </p>
  <img style="margin: 10px auto 20px; display: block;" src="{{ url_for('static', filename='assets/img/courses/ee/lesson17_2.png') }}" alt="">

{% endcall%}

{% call document_modal(doc_id="doc_ee_di_18", title="Lesson 18: Series-Parallel Circuits", hidden_val="doc_ee_hv_18", read="doc_ee_r_18") %}
  <p class="text-muted mb-0">
    In the last few lessons we have covered the fundamentals of circuit configuration, namely series and parallel circuits. In this lesson we look at circuits that have a combination of series and parallel configurations, fittingly named series-parallel circuits.
  </p>

  <h1 class="display-4">18.1 General Approach to Series-Parallel Circuits</h1>
  <p style="text-indent: 30px;">
    The process of ‘solving’ a series-parallel circuit means to boil it down to one single equivalent resistor, as that is a fundamental characteristic of any series-parallel circuit. Although there are more than one approaches to evaluating series-parallel circuits, there is a general formula that one can use, given by Robert Boylestad in his book Introductory Circuit Analysis. I shall take the liberty of paraphrasing his work here:
  </p>

  <ol>
    <li> <p style="margin-bottom: 0px;">Take a step back and look at the circuit holistically. Consider the overall approach that you might use to solve this circuit.</p>
    </li>
    <li> <p style="margin-bottom: 0px;">Examine each region of the circuit, determining whether it is in series or parallel with another branch of the circuit.</p> </li>
    <li> <p style="margin-bottom: 0px;">Don’t skip steps, redraw the circuit as you simplify it. This will help you to not lose track of which components you have or have not simplified.</p>
    </li>
    <li> <p style="margin-bottom: 0px;">Check your solution by seeing if the magnitude of the components seem reasonable.</p>
    </li>
  </ol>

  <h1 class="display-4">18.2 Reduce and Return Approach</h1>
  <p style="text-indent: 30px;">
    The reduce and return approach is a method of finding the voltage drop across a circuit component.
  </p>
{% endcall%}

{% endmacro %}

{% macro display_swift() %}
{% call document_modal(doc_id="doc_py_di_1", title="Variable", hidden_val="doc_py_hv_1", read="doc_py_r_1") %}
<h1 class="display-4">What is python?</h1>
<p>
  Python is a simple general-purpose programming language that is used in various fields to create endless projects. By learning python, you will be taking the first or one of the many steps to creating whatever you can dream with the power of software. The principles that you learn in this course can be applied to other programming languages with varying syntax and extra features between each one.
</p>

<h1 class="display-4">Let's Start Coding</h1>
<p>
  It is customary for someone starting programming for the first time to print out “Hello World” as a way to announce to the world(*your computer*) that you are starting to learn to code (*also used to check if environment is working*)
</p>
<p>
  Copy the following into your python editor and run your program!
<pre><code class = "lang-python">
  print("Hello World!")
  </code>
</pre>
  CONGRATULATIONS, you have written your first line of code in Python!
</p>

<h1 class="display-4">What is a variable?</h1>
<p>
  A variable in python is a simple pocket of data (words, characters, etc) that can hold/represent various values within your computer’s memory. <br>
  Variables can store different data types such as:
</p>
<ul>
  <li>Strings: “Hello World” -> Any Alphanumeric Character within Quotes</li>
  <li>Integer: 0, -2, 1 -> Any whole number</li>
  <li>Double: 0.0, -2.5, 1.2 -> Rational Numbers</li>
  <li>Boolean: True or False -> Conditional Values</li>
  <li>Other Data Types (We will go over this later)</li>
</ul>

<h1 class="display-4">How do we declare a variables?</h1>
<p>In order to declare(create/assign) a value to a variable we must do the following:</p>
{% call code_block() %}
<pre>
  <code class = "lang-python">
randomNum = 54 <br>#In this case, I set the variable 'randomNum' to the integer value: 54
  </code>
</pre>
{%endcall%}

<h1 class="display-4">How to access variable?</h1>
<p>Once you have declared or created a variable, you can access that variable by including its identifier(name) wherever you want in your code. We can set our message “Hello World!” to a variable and then print it.</p>
{% call code_block()%}
<pre>
  <code class = "lang-python">
message = "Hello World!" <br>
print(message)
  </code>
</pre>
    {%endcall%}

<p>Printing allows us as the user to be able to see the values of the variable in a console.</p>

<h1 class="display-4">Special Rules/Conventions</h1>
<p>In python there are certain key phrases the interpreter, the program that executes the instructions in your python script, has reserved for special purposes, these include:</p>
{% call code_block()%}
<pre>
  <code class = "lang-python">
  False await else import pass None break except in raise True class finally is return and continue for lambda try as def from nonlocal while assert del global not with async elif if
or yield
    </code>
</pre>
  {%endcall%}

<p>
  WARNING: do not name your variables with one of the keywords in this list as that might cause unintended errors within your program
<br> <br>
Conventions:
When you name your variables, try to name them to something that relates to your program. For example, if you are making a program to calculate how many miles you drive in a week, do not store the amount of miles traveled in a variable named m or n, rather call it based on its purpose such as: miles, totalMiles, etc. By doing this you make your program more readable for you and other programmers reviewing your code.
</p>
{%call code_block()%}
<pre>
  <code class = "lang-python">
#CALCULATEMILES.PY <br> <br>

m = 0 # WHAT IS M? <br>
milesTraveled = 0 # You can tell the variable's purpose by its name
    </code>
</pre>

{%endcall%}

<p>
  Camel Casing is the practice of writing phrases such that each word or abbreviation in the middle of the phrase begins with a capital letter, with no intervening spaces or punctuation. Examples: ‘cookiesInAJar’, ‘myFirstName’, ‘bananaDog’.
<br><br>
There is also Snake Case which is the practice of using underscores between words within a phrase. Example: “cookies_in_a_jar”, “my_first_name”, “banana_dog”.
<br><br>
You can use whatever convention you prefer, but try to stay consistent	or use a convention within your program.
</p>
{% endcall %}

{% call document_modal(doc_id="doc_py_di_2", title="Data Types", hidden_val="doc_py_hv_2", read="doc_py_r_2") %}
<p>Definition: A data type allows the computer to distinguish between certain data and determines what operations can be performed on that data. </p>
<h1 class="display-4">Integers</h1>
<p>Integers are whole numbers that are positive or negative.      </p>
{% call code_block()%}
<pre><code class = "lang-python">
x = 4 # The following is a counting number
negX = -4
</pre></code>
{% endcall %}

<h1 class="display-4">Floats</h1>
<p>Floats are rational numbers or numbers that have decimals in them. Even if a value can be rounded to an integer like 4.0, as long as the decimal exists it is defined as a float. </p>
{% call code_block()%}
<pre><code class = "lang-python">
y = 4.5 # The following is a rational number
negY = -4.5
</pre></code>
{% endcall %}

<h1 class="display-4">Booleans</h1>
<p>Booleans are truth values or the result of a comparison. For example, we can compare numbers: “3 is greater than 5”, since 3 is not greater than 5 the statement is False.   </p>
{% call code_block()%}
<pre><code class = "lang-python">
trueValue = True # Boolean Value
falseValue = False # Boolean Value
</pre></code>
{% endcall %}

<h1 class="display-4">Strings</h1>
<p>Strings are any combination of alphanumeric characters within quotation marks. For example, “I am a human!” or “4” are strings because the characters are within quotes. </p>
{% call code_block()%}
<pre><code class = "lang-python">
word = "genius"
stringNumber = "13234"
sentence = I like parks # DO NOT DO THIS
</pre></code>
{% endcall %}
<p>Note: Beginners often forget to add the quotations around characters they want to make a string. This will cause the interpreter to think that each word is a variable rather than a set of characters within a string, causing the program to crash.</p>

<h1 class="display-4">Other Types</h1>
<p>There are a couple of other types that are commonly used in python that are not listed here. We will delve into those types in later lessons, but if you are interested look up lists and dictionaries online.</p>

<h1 class="display-4">Commenting</h1>
<p>If you want to add a note or something in your program that you do not want the interpreter to run,  then you can comment it out. To do this put a ‘#’ before the phrase or the line of code. </p>

{% call code_block()%}
<pre><code class = "lang-python">
name = "Akshay" # This is a comment
# x = 5 -> following will not be run since it is a comment
</pre></code>
{% endcall %}
{% endcall%}

{% call document_modal(doc_id="doc_py_di_3a", title="Arthimetic Operators", hidden_val="doc_py_hv_3a", read="doc_py_r_3a") %}
<p>
In python we use variables to store data, so how would we perform actions with these variables? What actions could we perform? In this lesson, we will be going over some common operations we can perform with variables and certain types.    </p>
<h1 class="display-4">Basic Expression</h1>
<p>
  In the expression x + y, the plus sign is the operation and the variables x and y are the operands. Operands can be represented as variables, numbers or even expressions.      </p>

<h1 class="display-4">Arithmetic Operators</h1>
  <p>
    If you have ever been in a math class, all the operators in this list are the mathematical symbols you are familiar with (+, -, /, x). Math in python uses PEMDAS, which is an acronym for Parentheses, Exponents, Multiplication, Division,  Addition, and Subtraction. </p>
<strong>Addition Operator</strong>
<ul>
<li>+</li>
<li>adds together what is left and right of the operator</li>
<li>can be used with Integers, Floats, and Strings</li>
</ul>
{% call code_block()%}
a = 5 + 6 # adds 5 and 6 <br>
print(a) # prints 11 <br>
x = 3 <br>
y = 4 <br>
print(x + y) # prints the sum of x and y -> prints 7
{% endcall %}

<strong>Subtraction Operator</strong>
<ul>
<li>-</li>
<li>subtracts the value right operand with the left operand</li>
<li>can be used with Integers and Floats</li>
</ul>
{% call code_block()%}
<pre style="margin-bottom: 0px;">
a = 5 - 6 # subtracts 6 from 5
print(a) # prints -1
x = 3
y = 4
print(x - y) # prints the difference of x and y -> prints -1
</pre></code>
{% endcall %}

<strong>Multiplication Operator</strong>
<ul>
<li>*</li>
<li>product of the right and left operand</li>
<li>can be used with Integers and Floats</li>
</ul>
{% call code_block()%}
<pre style="margin-bottom: 0px;">
a = 5 * 6 # multiplies 5 with 6
print(a) # prints 30
x = 3
y = 4
print(x * y) # prints the product of x and y -> prints 12
</pre></code>
{% endcall %}

<strong>Division Operator</strong>
<ul>
<li>/</li>
<li>quotient of right and left operator</li>
<li>can be used with Integers and Floats</li>
</ul>
{% call code_block()%}
<pre style="margin-bottom: 0px;">
a = 4 / 2 # divides 4 with 2
print(a) # prints 2
x = 3
y = 4
print(x / y) # prints the quotient of x and y -> prints 0.75
</pre></code>
{% endcall %}

<strong>Exponent Operator</strong>
<ul>
<li>**</li>
<li>left operand to the power of the right operand
</li>
<li>can be used with Integers and Floats</li>
</ul>
{% call code_block()%}
<pre style="margin-bottom: 0px;">
a = 5 ** 6 # 5 to the power of 6
print(a) # prints 2
x = 3
y = 4
print(x ** y) # prints the quotient of x and y -> prints 81
</pre></code>
{% endcall %}

<strong>Modulus Operator</strong>
<ul>
<li>%</li>
<li>remainder from the quotient of the left and right operand
</li>
<li>can be used with Integers and Floats</li>
</ul>
{% call code_block()%}
<pre><code class = "lang-python">
a = 7 % 6 # the remainder of 7/6
print(a) # prints 1
x = 7.5
y = 4
print(x % y) # prints the remainder of x / y -> prints 3.5
</pre></code>
{% endcall %}
{% endcall %}

{% call document_modal(doc_id="doc_py_di_3b", title="Assignment Operators", hidden_val="doc_py_hv_3b", read="doc_py_r_3b") %}
<p>
This operator is in charge of assigning or giving values to variables. </p>

<strong>Assignment/Reassignment Operator</strong>
<ul>
<li>‘=’</li>
<li>sets the left operand to the right operand</li>
<li>used for declaring and reassigning variables </li>
<li>Reassignment: The process in which the data stored in a variable is overwritten with new data</li>
</ul>

{% call code_block()%}
<pre><code class = "lang-python">
x = 5 # Assignment or Declaration
print(x) # prints 5
x = 2 # Reassignment
print(x) # prints 2
x = "Banana" # Reassignment w/ Different Type
print(x) # prints "Banana"
</pre></code>
{% endcall %}

<p>NOTE: Unlike most other programming languages you can reassign a variable to any type.</p>

<strong>Arithmetic Assignment Operators</strong>
<ul>
<li>‘=’</li>
<li>Addition Assignment Operator -> “+=”</li>
<li>Subtraction Assignment Operator -> “-=”</li>
<li>Division Assignment Operator -> “/=”</li>
<li>Multiplication Assignment Operator -> “*=”</li>
<li>Modulus Assignment Operator -> “%=”</li>
</ul>

<p>Take the following line of code:</p>
{% call code_block()%}
<pre><code class = "lang-python">
x = 1 # Assigned 1 to x
print(x) # prints 1
x = x + 1 # Reassigned x to 1 + 1
print(x) # prints 2
</pre></code>
{% endcall %}

<p>The following probably looks confusing if you have ever done algebra before. Since x = x + 1 can never be equal, but in programming the ‘=‘ is about only assignment/reassignment not equality.</p>
<br>
<p>We declared the variable x to the integer value 1. Then we have the expression x + 1, which equals 1 + 1 = 2. We then use the assignment operator ‘=‘ to set x to equal 2.
NOTE: The x on the left of the ‘=’ operator is being set a value while the x on the right of the ‘operator’ is using its original value within the expression.</p>

{% call code_block()%}
<pre><code class = "lang-python">
x = 1
x += 1 # This is the same as x = x + 1
# The following concept applies to the arithemetic assignment operators
x -= 1 # x = x - 1
x *= 1 # x = x * 1
x /= 1 # x = x / 1
</pre></code>
{% endcall %}
{% endcall %}

{% call document_modal(doc_id="doc_py_di_3c", title="Relational Operators", hidden_val="doc_py_hv_3c", read="doc_py_r_3c") %}

<p>You may remember in the data types lesson, we talked about how booleans represent truth values or are the result of a comparison.</p>
<strong>Comparison Operators</strong>
<ul>
<li>< -> less than</li>
<li>> -> greater than        </li>
<li><= -> less than or equal</li>
<li>>= -> greater than or equal</li>
</ul>

<p>The following signs are used to compare numerical values such as integers and floats. It compares the left operand with the right operand and results in either True or False.</p>
{% call code_block()%}
<pre><code class = "lang-python">
print(3 < 4) # prints True
print(3 > 4) # prints False
print(3 <= 3) # prints True
print(3 >= 4) # prints False
</pre></code>
{% endcall %}

<strong>Equality Operator</strong>
<ul>
<li>== -> equal to</li>
<li>!= -> not equal to</li>
</ul>

<p>If you remember from the assignment operators, I told you that ‘=‘ is used for only assignment not assignment and equality(like in math class).
In order to check if two values are equal to each other we use the “==” operator. Like the inequality signs, the equality signs will compare the left and right operand resulting in a boolean value: True or False.</p>

{%call  code_block()%}
<pre><code class = "lang-python">
x = 1
print(x == 1) # prints True
print(x != 1) # prints False
</pre></code>
{% endcall %}

{% endcall %}

{% call document_modal(doc_id="doc_py_di_3d", title="Type Casting", hidden_val="doc_py_hv_3d", read="doc_py_r_3d") %}
<p>Type casting is defined as the process of taking a value of a different type and converting it into another data type.</p>
<strong>Type Casting Functions</strong>
<ul>
<li>int(arg) -> converts argument into an Integer</li>
<li>float(arg) -> converts argument into a float</li>
<li>str(arg) -> converts argument into a string</li>
<li>bool(arg) -> converts argument into a boolean</li>
</ul>

<p>
NOTE: An argument is the parameter of the function or the value that goes in between the parentheses. For example, print(“Hello, World”) takes in the one argument
</p>

<p>
For example, if we declare a variable x to the value 1, and then type cast it to a float and reassign that value to x. When we print x, it will equal 1.0. Now if this all seems jumbled up I’ll break it down line by line in code.
</p>

{% call code_block()%}
<pre><code class = "lang-python">
x = 1 # Declared x to 1
print(x) # prints 1
x = float(x) # type cast integer x to a float
print(x) # prints 1.0
</pre></code>
{% endcall %}

<p>You can convert integers to strings, strings to integers, the combinations are endless. Though there are some limitations, for example you can not convert a string with letters in it into numbers.</p>
{% call code_block()%}
<pre><code class = "lang-python">
x = “bananana”
x = int(x) # Throws a ValueError -> Program will crash here
</pre></code>
{% endcall %}

<p>The following is acceptable:</p>
{% call code_block()%}
<pre><code class = "lang-python">
x = “44”
x = int(x) # converts x from string to an integer
print(x) # prints 44
</pre></code>
{% endcall %}

<strong>Type Function</strong>
<p>type(arg) -> shows the data type of the argument</p>
{% call code_block()%}
<pre><code class = "lang-python">
number = 44
word = “chicken”
print(type(number)) # prints <‘class’ ‘int’>
print(type(string)) # prints <‘class’ ‘str’>
</pre></code>
{% endcall %}

<p>The words in between the single-quotes represent the type of that variable. For example, the variable number is of type int or Integer and the variable word is of type str or String.  </p>
{% endcall%}

{% call document_modal(doc_id="doc_py_di_4", title="String Operations", hidden_val="doc_py_hv_4", read="doc_py_r_4") %}
<h1 class="display-4">String Concatenation</h1>
<p>String concatenation is the act of taking two or more strings and adding them together. It is similar to compound words in English, where hot and dog are two separate words that can be combined into hotdog.</p>
{% call code_block()%}
<pre><code class = "lang-python">
compoundWord = "hot" + "dog"
print(compoundWord) # prints "hotdog"
</pre></code>
{% endcall %}
<h1 class="display-4">Formatted Strings</h1>
<p>String formatting is a similar concept to string concatenation in that it allows for multiple values to be combined together. Unlike string concatenation, it can take format data of types into a string.</p>
{% call code_block()%}
<pre><code class = "lang-python">
num = 70
pn = "soldier" + num # Throws a ValueError

pn = f"soldier {num}"
print(pn) # prints 'soldier 70'

hot = "hot"
dog = "dog"
print(f"{hot}{dog}") # Not very efficient, but it can be done
</pre></code>
{% endcall %}
<p>In order for the following to be a formatted string, there must be a lowercase ‘f’ before the double quotes, and any value you want inserted into the string must be put within curly braces.</p>
<h1 class="display-4">String Length</h1>
<p>You can get the length of a string by using the ‘len’ function</p>
{% call code_block()%}
<pre><code class = "lang-python">
word = "banana"
strLen = len(word)
print(strLen) # prints 6
</pre></code>
{% endcall %}
<h1 class="display-4">Title, Lowercase, Uppercase</h1>
<p>The title function, capitalizes every word within a string</p>
{% call code_block()%}
<pre><code class = "lang-python">
movie = "the emoji movie"
print(movie.title()) # prints 'The Emoji Movie'
</pre></code>
{% endcall %}
<p>The lowercase function, lowers every character within the string that is in the alphabet.</p>
{% call code_block()%}
<pre><code class = "lang-python">
memeText = "oK, bOOmEr"
print(memeText.lower()) # prints 'ok, boomer'
</pre></code>
{% endcall %}
<p>The uppercase function, capitalizes every character within the string that is in the alphabet.</p>
{% call code_block()%}
<pre><code class = "lang-python">
leaderName = "supreme commander bob"
print(leaderName.upper()) # prints 'SUPREME COMMANDER BOB'
</pre></code>
{% endcall %}
<h1 class="display-4">Stripping</h1>
<p>The strip function in python removes the unnecessary white space within a string. There are three variants of the strip function, rstrip, lstrip, and strip.</p>
<p>NOTE: txt is variable that represents a string in this case</p>
<ul>
<li>txt.lstrip() -> removes white space from the left of the non-space text</li>
<li>txt.rstrip() -> removes white space from the right of the non-space text</li>
<li>txt.strip() -> removes white space from both sides of the non-space text</li>
</ul>
{% call code_block()%}
<pre><code class = "lang-python">
x = "         chicken          "
print(x.lstrip()) # prints "chicken          "
print(x.rstrip()) # prints "         chicken"
print(x.strip()) # prints "chicken"
</pre></code>
{% endcall %}
<h1 class="display-4">Input</h1>
<p>The print function would take a value and display it onto the console, while the input function takes in a value and prompts the user to type a response in the console. You can save this value into a variable and perform string operations with it, since all input returns a string.</p>
{% call code_block()%}
<pre><code class = "lang-python">
name = input("What is your name: ") # asks user for their name
# user types in Bobby into console
print("Welcome, " + name) # prints 'Welcome, Bobby'
</pre></code>
{% endcall %}
<h1 class="display-4">Something cool you can do</h1>
{% call code_block()%}
<pre><code class = "lang-python">
name = input("What is your name: ")
name.strip().title() # applies both strip and title
print(f"Nice to meet you, {name}")
</pre></code>
{% endcall %}
<p>The following will remove white space from the text and will title the text appropriately even if the user gives some awkwardly formatted name. You can use input as a way to make your programs more.</p>
{% endcall %}

{% call document_modal(doc_id="doc_py_di_5a", title="If-Statement", hidden_val="doc_py_hv_5a", read="doc_py_r_5a") %}
<p>Conditional statements or if and else statements are the core to logic in programming.</p>
<h1 class="display-4">How to write a basic conditional statement?</h1>
{% call code_block()%}
<pre><code class = "lang-python">
if <'condition'>:
    # do something
</pre></code>
{% endcall %}
<p>You use the if keyword alongside a boolean expression with a colon indicating the end of that expression. </p>
<h1 class="display-4">What is a conditional statement?</h1>
<p>A conditional statement carries an action that will be executed (carried out) if the condition is met. For example, when you say “I will go outside if it is sunny”, the action is “I will go outside” and the condition is “If it is sunny”.  Let’s try to represent this in code</p>
{% call code_block()%}
<pre><code class = "lang-python">
sunny_weather = True # Symbolizes it's sunny outside

if sunny_weather:
    print("I will go outside")
</pre></code>
{% endcall %}
<p>In order for the if condition to perform the action, the condition must be met or the expression evaluates to True. For example, sunny_weather is equal to True and if statement checks if sunny_whether is True.. Since it is True, the condition was met and anything under the if condition will be run, such as the print function with the message “I will go outside”.  </p>
<p>Unlike most other programming languages, python uses idents rather than curly braces to indicate a block of code. A block of code in python is a group a python text that follows the same indentation.</p>
{% call code_block()%}
<pre><code class = "lang-python">
x = 4 # No Indentation // Block 1

if x < 5: # No Indentation // Block 1
    print("X is less than 5") # 1 Tab of Indentation // Block 2

print("I like numbers") # No indentation // Block 1
</pre></code>
{% endcall %}
<p>When the if condition is true it will execute code that is indented or within Block 2 and then run the last print statement. When the if condition is false it will skip the code within block 2 and run the last print statement. </p>
<p>Tabbing and Indenting might be a stylistic choice for Cornell notes, but in Python it is key component in the interpreter being able to understand your code.</p>
{% endcall %}

{% call document_modal(doc_id="doc_py_di_5b", title="Else-Statement", hidden_val="doc_py_hv_5b", read="doc_py_r_5b") %}
<p>In our current sunny_weather program, we will go outside if the weather is sunny, but we do nothing if it is not sunny. Let’s change our program so  that when there is no sunny weather(sunny_weather is false) we will stay at home.</p>
{% call code_block()%}
<pre><code class = "lang-python">
sunny_weather = True

if sunny_weather == True:
    print("I will go outside")
else:
    print("I will stay at home")
</pre></code>
{% endcall %}
<strong>What does our program say?</strong>

<p>
It says <strong>if</strong> the weather is sunny then print “I will go outside” or <strong>else</strong>, if the weather is not sunny, print “I will stay at home”. The code block under the else statement will only be run if the condition in the if statement evaluates to False and unlike the if condition it does not have a condition of its own.
</p>
<p> So what aspect of our code do we have to change for the code to execute the block under the else statement?
</p>
<p>ǝslɐℲ = ɹǝɥʇɐǝʍ‾ʎuuns</p>

<strong>How does it work?</strong>
<p>An else statement will only be triggered when if the condition is false.
</p>
{% endcall%}

{% call document_modal(doc_id="doc_py_di_5c", title="Elif-Statement", hidden_val="doc_py_hv_5c", read="doc_py_r_5c") %}
<p>In our program, we will go outside if the weather is sunny or else we will stay at home. That means we are accounting for two scenarios, when the weather is sunny and not sunny. If you have ever been outside you know the weather can sometimes be cloudy, rainy, stormy, snow, etc. We can create a program to check for multiple different weather types</p>
{% call code_block()%}
<pre><code class = "lang-python">
weather = "sunny"

if weather == "sunny":
    print("I will go outside")
else:
    print("I will stay at home")
</pre></code>
{% endcall %}
<p>In order to check for all of the weather we will use the else if statement. Similar to the else statement, it will only run when the if condition is false, but there is a twist to it. Unlike the else statement, else if statements take in a condition.</p>
{% call code_block()%}
<pre><code class = "lang-python">
if <'condition'>:
    # do something
elif <'condition2'>:
    # do this when if condition fails
else:
    # do this when if and elif conditions fail
</pre></code>
{% endcall %}

<p>Let us check the different weather conditions with if, elif, and else statements</p>
{% call code_block()%}
<pre><code class = "lang-python">
weather = "rainy"

if weather == "sunny":
    print("I will go outside")
elif weather == "cloudy":
    print("I will go outside with my jacket.")
elif weather == "rainy":
    print("This is the best time to take a nap.")
elif weather == "snowy":
    print("I will roll around in the snow.")
else:
    print("I will stay at home")
</pre></code>
{% endcall %}
<p>The following will output “This is the best time to take a nap” into the console window. This is because it will skip the first two conditions since “rainy” does not equal to “sunny” and “cloudy”. Then it hits the third statement, the program executes the block under the statement. Since a condition was fulfilled, no other elif or else statement will be checked.</p>
{% endcall%}

{% call document_modal(doc_id="doc_py_di_5d", title="Elif-Statement", hidden_val="doc_py_hv_5d", read="doc_py_r_5d") %}
<p>A bird’s nest is collection of various objects stacked on top of each other, this concept is mimicked in programming. If-conditions can be stacked together in a similar manner.</p>
{% call code_block()%}
<pre><code class = "lang-python">
if <'condition1'>:
    if <'condition2'>:
        if <'condition3'>:
            if <'condition4'>:
                if <'condition5'>:
                    print("Hello, World")
</pre></code>
{% endcall %}
<p>As you can see each if-condition builds off of each other, so in order to reach the print statement every condition(1-5) must be met. Nesting does not necessarily have to build off of an if-condition, for example:</p>
{% call code_block()%}
<pre><code class = "lang-python">
if <'condition1'>:
    print("Inside if")
else:
    if <'condition2'>:
        print("Inside if inside an else condition")
    elif <'condition3'>
        print("inside elif inside else condition")
    else:
        print("else inside else condition")
</pre></code>
{% endcall %}
<p>You will most probably use nesting if you have multiple conditions that you want to check. Nesting is one of the ways to solve this problem, the other way is to use Logical Operators.
</p>
{% endcall %}

{% call document_modal(doc_id="doc_py_di_5e", title="Logical Operators", hidden_val="doc_py_hv_5e", read="doc_py_r_5e") %}
<ul>
<li>not -> opposite of the current boolean value</li>
<li>and -> evaluates true if and only if left and right operands are both equal to true</li>
<li>or -> evaluates true when at-least one operand is equal to true</li>
</ul>
<strong>not</strong>
{% call code_block()%}
<pre><code class = "lang-python">
x = False

if not x: # if not False = if True
    print("Success")
</pre></code>
{% endcall %}
<strong>and</strong>
{% call code_block()%}
<pre><code class = "lang-python">
x = True
y = False

if x and y:
    print("x and y are both True")
else:
    print("one or both of the operands equals False")

# prints "one of the operands equals False"
</pre></code>
{% endcall %}
<strong>or</strong>
{% call code_block()%}
<pre><code class = "lang-python">
x = True
y = False

if x or y:
    print("one of the operands equals True")
else:
    print("both of the operands equals False")

# prints "one of the operands equals True"
</pre></code>
{% endcall %}
<p>In a nested if condition, all of the conditions must be met or the expressions must be equal to True. The following concept is similar to the ‘and’ operator which states that both operands must be equal to true. Quick note: operands can be expressions, variables, values, or anything that represents a value.</p>
{% call code_block()%}
<pre><code class = "lang-python">
x = True
y = False

# Nested If-Conditions
if x:
    if y:
        print("x and y are True")
    else:
        print("one or both of the operands are false")
else:
    print("one or both of the operands are false")
</pre></code>
<br>
<pre><code class = "lang-python">
# If-Condition with And Operator
if x and y:
    print("x and y are True")
else:
    print("one or both of the operands are false")
</pre></code>
{% endcall %}
<p>As you can see, there are many different ways to approach the same problem; some solutions maybe more efficient than others and you must use your own discretion to decide how you want to code that solution.</p>
{% endcall%}

{% call document_modal(doc_id="doc_py_di_6a", title="List", hidden_val="doc_py_hv_6a", read="doc_py_r_6a") %}
<p>A list in python is a group or collections of values, these values do not have to share the same data type. Lists are an iterable which means that it is able to return its members one at a time. Similar to a shopping list, you can have vegetables, fruits, snacks, and other goodies all within the same list</p>
<p>Declarion:</p>
{% call code_block()%}
<pre><code class = "lang-python">
x = [1, "2", True, 3.0]
</pre></code>
{% endcall %}
<strong>Breaking the Syntax Down</strong>
<ul>
<li>[] - the square brackets holds the lists</li>
<li>, - commas separate each value/item in the list</li>
</ul>
<p>Now that you can create lists in python how can you access individual values within the list. The following would be similar to reading an item off of a shopping list. Let’s demonstrate with a shopping list and with code:</p>
{% call code_block()%}
<pre><code class = "lang-python">
-- Shopping List --
1. Banana
2. Chicken
3. Apple
4. Peas
</pre></code>
{% endcall %}
{% call code_block()%}
<pre><code class = "lang-python">
shopping_list = ["Banana", "Chicken", "Apple", "Peas"]
</pre></code>
{% endcall %}
<p>If we want to check the very first item of our shopping list, we would normally look at the top or the number 1. In our shopping list we counted starting from 1, but in python lists index/position starts at 0. So in order to access the first item, we get the item in the 0-th index, the second item is in the 1st-index, and so on.</p>
{% call code_block()%}
<pre><code class = "lang-python">
print(shopping_list[0]) # prints Banana
print(shopping_list[3]) # prints Peas
</pre></code>
{% endcall %}
<p>The process of accessing individual values from an iterable data type such as a list, string, range, etc. You can use the following syntax of subscripting on strings too.</p>
<p>Breaking the Syntax down: <br>
list[i] - the bracket after a list represents accessing a value at the i-th index, where ‘i’ is an integer. NOTE: list is a keyword, but it was used to illustrate you need a variable that is of list type(it contains a list).  </p>
<p>ERROR: When accessing items/values from a list, you can not specify an index that is bigger than the [list’s length - 1], as it will create an error.</p>
{% call code_block()%}
<pre><code class = "lang-python">
You can have lists in lists
x = [[1,2], [3,[4,5]]]
# In order to access the value 5
print(x[1][1][1])
#Print each individually to see how it narrows down the value
</pre></code>
{% endcall %}
{% endcall%}

{% call document_modal(doc_id="doc_py_di_6b", title="Tuples & Sets", hidden_val="doc_py_hv_6b", read="doc_py_r_6b") %}
<h1 class="display-4">Tuples</h1>
<p>Tuples follow similar principles to lists with a key limitation: they are unchangeable. Once a tuple is declared, its values and size can not be changed.
<br>
Declarion:
</p>
{% call code_block()%}
<pre><code class = "lang-python">
coord_point = (1,2)

print(coord_point[0]) # prints 1
</pre></code>
{% endcall %}
<h1 class="display-4">Sets</h1>
<p>Sets also follow similar principles to lists, but they do not allow duplicate values and they are not structured. Any duplicate values in assignment will be removed until only one of each value remains. Unlike tuples and lists, you are not able to subscript or access individual values within a set. </p>
{% call code_block()%}
<pre><code class = "lang-python">
values = {23,42,23,1,2,3}
print(values) # {23,42,1,2,3}

print(values[0]) # Throws TypeError and crashes program
</pre></code>
{% endcall %}
{% endcall %}

{% call document_modal(doc_id="doc_py_di_6c", title="Type Casting", hidden_val="doc_py_hv_6c", read="doc_py_r_6c") %}
<p>Type casting is defined as the process of taking a value of a different type and converting it into another data type.</p>
<p>NOTE: An argument is the parameter of the function or the value that goes in between the parentheses. For example, print(“Hello, World”) takes in one argument .</p>
<strong>Type Casting Function</strong>
<ul>
<li>list(arg) -> converts argument into a list</li>
</ul>
{% call code_block()%}
<pre><code class = "lang-python">
name = "string"
name = list(name) # converts string into a list
print(name) # prints ['s', 't', 'r', 'i', 'n', 'g']

alphabet = {'a', 'b', 'c'}
alphabet = list(alphabet)
print(alphabet) # prints ['a', 'b', 'c']
</pre></code>
{% endcall %}
<ul>
<li>set(arg) -> converts argument into a set</li>
</ul>
{% call code_block()%}
<pre><code class = "lang-python">
fruit = "banana"
fruit = set(fruit) # converts string into a list
print(fruit) # prints {'b', 'a', 'n'}


alphabet = ['a', 'a', 'b', 'c']
alphabet = set(alphabet)
print(alphabet) # prints {'a', 'b', 'c'}
</pre></code>
{% endcall %}
<ul>
<li>tuple(arg) -> converts argument into a tuple</li>
</ul>
{% call code_block()%}
<pre><code class = "lang-python">
animal = "chicken"
chicken = tuple(chicken) # converts string into a list
print(chicken) # prints ('c', 'h', 'i', 'c', 'k', 'e', 'n')


alphabet = ['a', 'b', 'c', 'd']
alphabet = set(alphabet)
print(alphabet) # prints ('a', 'b', 'c', 'd')
</pre></code>
{% endcall %}
{% endcall%}

{% call document_modal(doc_id="doc_py_di_6d", title="List Functions", hidden_val="doc_py_hv_6d", read="doc_py_r_6d") %}
<h1 class="display-4">Length</h1>
<p>You can get the length of a list by using the ‘len’ function</p>
{% call code_block()%}
<pre><code class = "lang-python">
shopping_list = ["Banana", "Chicken", "Apple", "Peas"]
strLen = len(shopping_list)
print(strLen) # prints 4
</pre></code>
{% endcall %}
<h1 class="display-4">Append</h1>
<p>You can add values to the end of a list by using the append function</p>
{% call code_block()%}
<pre><code class = "lang-python">
shopping_list = ["Banana", "Chicken", "Apple", "Peas"]
shopping_list.append("Smuckers")

print(shopping_list) # prints ["Banana", "Chicken", "Apple", "Peas", "Smuckers"]
</pre></code>
{% endcall %}
<h1 class="display-4">Pop</h1>
<p>You can remove the values at the end of the list by using the pop function. Though you can select which values you can pop by providing an index through the pop function. The pop function also gives the value it popped from the list.</p>
{% call code_block()%}
<pre><code class = "lang-python">
shopping_list = ["Banana", "Chicken", "Apple", "Peas"]
print(shopping_list.pop()) # prints "Peas"

shopping_list.pop(0)
print(shopping_list) # prints ["Chicken", "Apple"]
</pre></code>
{% endcall %}
<h1 class="display-4">Remove</h1>
<p>Similar to the pop function, the remove function removes values from a list. The pop function removes values based on their index, while the remove function removes values in a list based on their value.</p>
{% call code_block()%}
<pre><code class = "lang-python">
shopping_list = ["Banana", "Chicken", "Apple", "Peas"]
shopping_list.remove("Apple")

print(shopping_list) # prints ["Banana", "Chicken", "Peas"]
</pre></code>
{% endcall %}
<p>The following is not an exhaustive list of everything you can do with lists in python, but it provides basic functions you will use in assignments. You do not need to memorize each and every function, rather take a problem and be able to understand how to solve it. Once you map out your solution you can search the required functions to perform the solution.</p>
{% endcall%}


{% call document_modal(doc_id="doc_py_di_7", title="Dictionaries", hidden_val="doc_py_hv_7", read="doc_py_r_7") %}
<p>In python dictionaries are a collection of key value pairs.</p>
<p>Declaration:</p>
{% call code_block()%}
<pre><code class = "lang-python">
empty_dict = {}
num_dict = {0: "Banana", 1: "Fruit"}
user_info = {"name": "John", "age": 12}
</pre></code>
{% endcall %}
<p>The value to the left of the colon represents the key and the value to the right represents the value. </p>

<strong>Accessing Elements of A Dictionary</strong>
{% call code_block()%}
<pre><code class = "lang-python">
print(num_dict[0]) # prints "Banana"
print(user_info["age"]) # prints 12
</pre></code>
{% endcall %}

<strong>Adding Values to a Dictionary</strong>
{% call code_block()%}
<pre><code class = "lang-python">
dd = {}
dd['name'] = "John" # Add Value to Dictionary
print(dd['name']) # prints 'John'

dd['name'] = "Mary" # Update Value of Dictionary
print(dd['name']) # prints 'Mary'
</pre></code>
{% endcall %}

<strong>Break Down the Syntax</strong>
<ul>
<li>obj[key] = value</li>
<li>obj - represents the dictionary you want to add a value to</li>
<li>key - sets the key of the pair</li>
<li>value - sets the value to the key</li>
</ul>

<strong>Traversing through a Dictionary</strong>
{% call code_block()%}
<pre><code class = "lang-python">
user_info = {"name": "John", "age": 12}

for key, value in user_info:
    print(f"{key} : {value}")
</pre></code>
{% endcall %}
{% endcall %}

{% call document_modal(doc_id="doc_py_di_8a", title="For Loops", hidden_val="doc_py_hv_8a", read="doc_py_r_8a") %}
<p>Sometimes when you code you want to repeat an action multiple times, you could 1) copy paste it that many times or 2) finish this lesson. In this lesson we will be going over the for loop and the while loop.
</p>
<h1 class="display-4">For Loop</h1>
<p>The for loop will repeat an action within its code block based on what it’s iterating or traversing through. For example, you could loop through a range of numbers.</p>
{% call code_block()%}
<pre><code class = "lang-python">
for i in range(10)
print(i)

# prints numbers from 0 to 9
</pre></code>
{% endcall %}
<p>You can iterate through a variety of things such as strings, lists, and ranges.</p>
{% call code_block()%}
<pre><code class = "lang-python">
word = "banana"
for letter in word:
    print(letter)

# prints each letter in banana 1 by 1
</pre></code>
{% endcall %}
{% call code_block()%}
<pre><code class = "lang-python">
# prints each number in the numbers list
numbers = [1,4,5,67,8,2]
for number in numbers:
    print(number)

# alternative way
numbers = [1,4,5,67,8,2]
for i in range(len(numbers)):
    print(numbers[i])
</pre></code>
{% endcall %}
<strong>Breaking down how it works</strong>
<ul>
<li>‘for’ keyword indicates that it is a for loop</li>
<li>‘in’ operator assigns a value from the right operand to the left operand</li>
<li>left operand is the variable that temporarily holds each individual value</li>
<li>right operand is the value you are cycling through</li>
<li>‘:’ indicates the expression has ended</li>
</ul>
<p>In the first example, we loop through a range from 0 to 9(10 -1). Every time the code block is run the variable ‘i’ is updated to next value until it reaches 9 or the end of the range. You can apply the same concept to strings and lists, as the left operand is updated to the next value until it reaches the end of the string or list.</p>
{% endcall %}

{% call document_modal(doc_id="doc_py_di_8b", title="While Loops", hidden_val="doc_py_hv_8b", read="doc_py_r_8b") %}
<p>Similar to if-conditions, while loops work based on whether a condition evaluates to True. The loop will continue to loop while the condition is true.</p>
{% call code_block()%}
<pre><code class = "lang-python">
count = 0

while count < 10:
    print(count)
    count+=1
</pre></code>
{% endcall %}
<p>The following while loop is similar to how a for loop loops through a range of numbers.</p>
<p>While loops are mostly used when there is not a defined time limit or you are checking for a certain state. For example, a text program may loop with same input until the user types in quit. </p>
{% call code_block()%}
<pre><code class = "lang-python">
us_msg = ""

while us_msg != "quit":
    print("Type quit to exit the program")
    us_msg = input("What is your name: ")
    print("Welcome, " + us_msg)
</pre></code>
{% endcall %}
{% endcall %}

{% call document_modal(doc_id="doc_py_di_8c", title="Break, Continue, and Pass", hidden_val="doc_py_hv_8c", read="doc_py_r_8c") %}
<p><strong>break</strong> -  when the program reaches the break statement it exits out of the loop <br></p>
<p><strong>continue</strong> -  when the program reaches the continue statement, it stops running code in that code block and then continues the loop <br></p>
<p><strong>pass</strong> -  pass means there is no code to run in the block and is used mostly as a placeholder for code that will be written later <br></p>
{% call code_block()%}
<pre><code class = "lang-python">
#Program stops when it reaches the letter 'm'

word = "chicken-man"

for letter in word:
    if letter == "m":
        break # stops the loop and will not run print statment below
    else:
        print(letter)
</pre></code>
{% endcall %}
{% call code_block()%}
<pre><code class = "lang-python">
#Program that only prints even numbers

count = 0
while count < 100: # from 0-99
    if count % 2 == 1: # if number is odd, then stop code
        continue
    else:
        print(n)
    count += 1
</pre></code>
{% endcall %}
{% call code_block()%}
<pre><code class = "lang-python">
# Program that does nothing

for x in range(10):
    pass
</pre></code>
{% endcall %}
{% endcall%}

{% call document_modal(doc_id="doc_py_di_8d", title="Nesting Loops", hidden_val="doc_py_hv_8d", read="doc_py_r_8d") %}
<p>Similar to the concept of nesting if conditions, you can nest loops. </p>
{% call code_block()%}
<pre><code class = "lang-python">
# Traversing through a matrix
matrix = [[1,2], [3,4]]

for i in range(len(matrix)): # loops through rows
    for j in range(len(matrix[i])) # columns per row
        print(matrix[i][j])
</pre></code>
{% endcall %}
<p>The first for loop goes through the rows in the matrix and the second loop goes through the columns of the matrix. Let’s run the code through words: </p>
<p>
<pre><code class = "lang-python">
Program starts
matrix = [[1,2], [3,4]]
First for loop starts
i = 0
Second for loop starts
j = 0
print(matrix[0][0]) # i=0, j=0
Second for loop updates
j = 1
print(matrix[0][1]) # i=0, j=1
Second for loop finishes
First for loop updates
Second for loop starts
i = 1
j = 0
print(matrix[1][0]) # i=1, j=0
Second for loop updates
j = 1s
print(matrix[1][1]) # i=1, j=1
Second loop finishes
First loop finishes
Program finishes
</pre></code>
</p>

{% endcall %}

{% call document_modal(doc_id="doc_py_di_9", title="Functions", hidden_val="doc_py_hv_9", read="doc_py_r_9") %}
<p>Throughout your programming journey you have been using various functions to simplify your code. </p>
<p>Declarion:</p>
{% call code_block()%}
<pre><code class = "lang-python">
def function_name():
pass # put code body here
</pre></code>
{% endcall %}
<p>Functions allow for blocks of code to be reused in various parts of the program.</p>
{% call code_block()%}
<pre><code class = "lang-python">
def greeting():
print("Hi, welcome to our shop!")

greeting() # call the function
</pre></code>
{% endcall %}
<p>When you call a function you are using its defined named to execute its code-block. We defined a function with the name greeting, and when greeting is called it will print “Hi, welcome to our shop!”.</p>
{% call code_block()%}
<pre><code class = "lang-python">
def function_name(arg):
print(arg)
</pre></code>
{% endcall %}
<p>Functions have the ability to take on parameters and perform logic with them. For example, you can create a function that passes in a customer’s name and prints out a unique message for them.</p>
{% call code_block()%}
<pre><code class = "lang-python">
def cust_greeting(name):
print("Hi " + name + ", welcome to our shop!")

cust_greeting("Robert")
# prints "Hi Robert, welcome to our shop!"
</pre></code>
{% endcall %}
<p>We can also use functions to take input as parameters and return an output that can be stored into a variable. We do the following by using the ‘return’
keyword.</p>
{% call code_block()%}
<pre><code class = "lang-python">
def add_num(a, b):
return a + b

c = add_num(1,2)
print(c) # prints 3
</pre></code>
{% endcall %}
<p>As you can see the numbers, took the place of the letters in the function and the position matters. In the add_num function a=1 and b=2, and it returns the sum of a and b into c.</p>

{% endcall %}


{% call document_modal(doc_id="hw_py_di_1", title="Data Type Homework", hidden_val="hw_py_hv_1", read="hw_py_r_1", size="lg") %}
<pre><code class = "lang-python">
1. Set a varible to an integer. Print this variable.

2. Set a variable to a float. Print this variable.

3. Set a variable to a string. Print this variable.

4. Set a variable to a boolean. Print this variable.

5. Write a piece of code and then comment it out.
</pre></code>
{% endcall %}

{% call document_modal(doc_id="ans_py_di_1", title="Data Type HW Answers", hidden_val="ans_py_hv_1", read="ans_py_r_1", size="lg") %}
<pre><code class = "lang-python">
# 1. Solution
a = 5
print(a)

# 2. Solution
b = 3.0
print(b)

# 3. Solution
c = "Banana"
print(c)

# 4. Solution
d = True
print(d)

# 5. Solution
# The following is a commented line of code
</pre></code>
{% endcall %}

{% call document_modal(doc_id="hw_py_di_2a", title="Operations Homework", hidden_val="hw_py_hv_2a", read="hw_py_r_2a", size="lg") %}
<p>
# Arthimetic Operators - Print the values of the variables <br>
1. Set a variable to the sum of two numbers, (addition) <br>
2. Set a variable to the difference of two numbers, (subtraction) <br>
3. Set a variable to the product of two numbers, (multiplication) <br>
4. Set a variable to the quotient of two numbers, (division) <br>
5. Set a variable to an a number to the power to another number (exponents) <br>
6. Set a variable to find the remainder between two numbers (modulo)
</p>

<p>
# Assignment Operators - Print the values of the variables <br>
1. Set a value to a variable then reassign that variable to a different value.
</p>

<p>
# Arthimetic Assignment Operators - Print the values of the variables <br>
1. Set a variable to an integer value, and then use the '+=' operator to increase the variable's value by 2. <br>
2. Set a variable to an integer value, and then use the '-=' operator to decrease the variable's value by 2. <br>
3. Set a variable to an integer value, and then use the '*=' operator to multiply the variable's value by 2. <br>
4. Set a variable to an integer value, and then use the '/=' operator to divide the variable's value by 2. <br>
5. Set a variable to an integer value, and then use the '%=' operator to divide the variable's value by 2 and set its remainder. <br>
6. Set a variable to an integer value, and then use the '**=' operator to put a variable to a power to 2. <br>
</p>

<p>
# Relational Operator - Print the comparisons <br>
# Comparison Operator <br>
1. Set two variables to integer values and use the '>' sign to  compare the them. <br>
2. Set two variables to integer values and use the '<' sign to  compare the them. <br>
3. Set two variables to integer values and use the '>=' sign to  compare the them. <br>
4. Set two variables to integer values and use the '<=' sign to  compare the them.
</p>

<p>
# Equality Operator - Print the comparisons <br>
1. Set two variables to integer values and use the '==' sign to check if the variables are equal. <br>
2. Set two variables to integer values and use the '!=' sign to check if the variables are not equal.
</p>

<p>
# Type Casting <br>
1. Set a variable to a string that resembles an integer(that has no non-numerical characters). Reassign the variable by type casting it to an integer using 'int()'. <br>
2. Set a variable to a string that resembles an float(that has no non-numerical characters). Reassign the variable by type casting it to an integer using 'float()'. <br>
3. Set a variable to a string that is not empty. Reassign the variable by type casting it to an integer using 'bool()'. <br>
4. Set a variable to a string that is empty. Reassign the variable by type casting it to an integer using 'bool()'. <br>
5. Set a variable to any type that is not a string. Reassign the variable by type casting it to an string using 'str()'. <br>
6. Go through questions 1-5, but print the type of the variable after you type-cast it using the 'type()' function. <br>
7. Set a variable to any type, and reassign it using any of the type-casting functions. Print the variable after type-casting and try different combinations with different types and type-casting functions. You may get errors with certain combinations, so take note of what causes these errors. <br>
</p>

{% endcall %}

{% call document_modal(doc_id="ans_py_di_2a", title="Data Type HW Answers", hidden_val="ans_py_hv_2a", read="ans_py_r_2a", size="lg") %}
<pre><code class = "lang-python">
#Arthimetic Operators
# 1. Solution
x = 5 + 6
print(x)

# 2. Solution
x = 5 - 6
print(x)

# 3. Solution
x = 5 * 6
print(x)

# 4. Solution
x = 5 / 6
print(x)

# 5. Solution
x = 5 ** 6
print(x)

# 6. Solution
x = 6 % 5
print(x)

# Assignment Operators
# 1. Solution
x = 10 # Assignment
x = 5 # Reassignment
print(x)

# Arthimetic Assignment Operators
# 1. Solution
x = 0
x += 2
print(x)
# 2. Solution
x = 0
x -= 2
print(x)
# 3. Solution
x = 5
x *= 2
print(x)
# 4. Solution
x = 6
x /= 2
print(x)
# 5. Solution
x = 3
x **= 2
print(x)
# 6. Solution
x = 2
x %= 2
print(x)

# Relational Operators
# Comparison Operator
# 1. Solution
a = 2
b = 3
print(a < b)
# 2. Solution
a = 2
b = 3
print(a > b)
# 3. Solution
a = 3
b = 3
print(a <= b)
# 4. Solution
a = 2
b = 3
print(a >= 3)

#Equality Operator
# 1. Solution
a = 2
b = 3
print(a == b)
# 2. Solution
a = 2
b = 3
print(a != b)

# Type Casting
# 1. Solution
a = "4"
a = int(a)
print(a)
# 2. Solution
b = "4.5"
b = float(a)
print(a)
# 3. Solution
c = "Banana"
c = bool(c)
print(c)
# 4. Solution
d = ""
d = bool(d)
print(d)
# 5. Solution
e = 12319827.23421
e = str(e)
print(e)
# 6. Solution
# Since I used different variables for each question, the solution will come after the code in 1-4.
# 6.1
print(type(a))
# 6.2
print(type(b))
# 6.3
print(type(c))
# 6.4
print(type(d))
# 6.5
print(type(e))

# 7. Solution
# Answers will vary on what you tested with
</pre></code>
{% endcall %}

{% call document_modal(doc_id="hw_py_di_2b", title="String Operation Homework", hidden_val="hw_py_hv_2b", read="hw_py_r_2b", size="lg") %}
<p>
1. Set two variables to string values and then use string concatenation to combine them into one string. Assign this combined variable to a new variable, print this new variable.
<br>
2. Do question 1, except perform string concatenation with more than two strings.
<br>
3. Set two variables to an integer value and a string value use string formatting to combine them into one string. Put the variables within '{}' so then they will mesh into the string.
<br>
4. Set a variable to a string value and use the 'len()' function to print the string's length.
<br>
5. Set a variable to a string with all lower-case characters. Then reassign variable to the string but upper-case with the 'upper()' function.
<br>
6. Set a variable to a string with all upper-case characters. Then reassign variable to the string but lower-case with the 'lower()' function.
<br>
7. Set a variable to a string with all lower-case characters with spaces. Then reassign variable to the string but with title capitilzation with the 'title()' function.
<br>
8. Set a variable to a string with white space aka spaces to the left and right of your non-space-characters. Reassign the variable to the variable's white-space stripped from the right, 'rstrip()' function.
<br>
9. Set a variable to a string with white space aka spaces to the left and right of your non-space-characters. Reassign the variable to the variable's white-space stripped from the left, 'lstrip()' function.
<br>
10. Set a variable to a string with white space aka spaces to the left and right of your non-space-characters. Reassign the variable to the variable's white-space stripped from the both sides, 'strip()' function.
<br>
11. Set a variable to the output of an input function. Reassign the variable to the capitalized version of the variable using the 'title()' function.
<br>
12. Set a variable to the output of an input function. Reassign the variable to the type-casted function -- remember certain combinations will cause errors, so beware of that.
<br>
</p>

{% endcall%}

{% call document_modal(doc_id="ans_py_di_2b", title="String Operations HW Answers", hidden_val="ans_py_hv_2b", read="ans_py_r_2b", size="lg") %}
<pre><code class = "lang-python">
# 1. Solution
word1 = "hot"
word2 = "dog"
combined_word = word1 + word2
print(combined_word)

# 2. Solution
word1 = "hot"
word2 = "dog"
combined_word = word1 + word2 + ",Banana" + ",Chicken"
print(combined_word)

# 3. Solution
name = "Chicken"
num = 55
my_name = f"My name is {name} {num}!"
print(my_name)

# 4. Solution
animal = "Chicken"
print(len(animal))

# 5. Solution
a = "chicken"
a = a.upper()
print(a)

# 6. Solution
b = "CHICKEN"
b = b.lower()
print(b)

# 7. Solution
c = "fried chicken"
c = c.title()
print(c)

# 8. Solution
space_text = "   asdf   "
space_text = space_text.rstrip()
print(space_text)

# 9. Solution
space_text = "   asdf   "
space_text = space_text.lstrip()
print(space_text)

# 10. Solution
space_text = "   asdf   "
space_text = space_text.strip()
print(space_text)

# 11. Solution
name = input("Please enter your full name: ")
print(name.title())

# 12. Solution
num = input("Type in a number: ")
num = int(num)
print(num)
# short-hand way: num = int(input("Type in a number:"))
</pre></code>
{% endcall%}

{% call document_modal(doc_id="hw_py_di_2c", title="Function Homework", hidden_val="hw_py_hv_2c", read="hw_py_r_2c", size="lg") %}
<p>
1. Create a function that prints a special message when it called. Call this function.
<br>
2. Create a function that takes a single integer argument and prints out that number to the power of 2. Call this function.
<br>
3. Create a function that takes a two integer arguments and prints out the product of the arguments. Call this function.
<br>
4. Create a function that takes a single integer argument and return that number to the power of 2. Set a variable to the value that is returned when the function is called. Print this variable.
<br>
5. Create a function that takes a single integer argument. The  function should loop from 0 to the argument's value, and should calculate the sum of all the numbers in that range(0, argument's value) and return it.
<br>
</p>

{% endcall%}

{% call document_modal(doc_id="ans_py_di_2c", title="Function Homework", hidden_val="ans_py_hv_2c", read="ans_py_r_2c", size="lg") %}
<pre><code class = "lang-python">
#1. Solution
def send_message():
    print("Hello, Human!")
send_message()

#2. Solution
def square(num):
    print(num**2)
square(2)

#3. Solution
def multiply(a, b):
    print(a*b)
multiply(2,2)

#4. Solution
def square_function(num):
    return num**2
squared_num = square_function(5)
print(square_num)

#5. Solution
def sum_all(end_num):
    total = 0
    for num in range(0, end_num):
        total += num
    print(total)
</pre></code>
{% endcall %}

{% call document_modal(doc_id="hw_py_di_3", title="Conditionals Homework", hidden_val="hw_py_hv_3", read="hw_py_r_3", size="lg") %}

# COPY PASTE THIS IN YOUR PYTHON EDITOR
{% call code_block()%}
<pre><code class = "lang-python">
if <'condition'>:
    # do something
else:
    # do something else
</pre></code>
{% endcall %}

# E. Set a variable to a boolean. Create an if-else-statement that checks if an integer is greater than equal to 5. Print a unique message for the if-statment and the else-statement. <br>
# E. Solution <br>

{% call code_block()%}
<pre><code class = "lang-python">
a = 4
if a >= 5:
    print("a is greater than or equal to 5")
else:
    print("a is less than 5")
</pre></code>
{% endcall %}

# 1. Set a variable to a string. Create an if-else-statement that checks if a string is equal to "Banana". Print a unique message for the if-statment and the else-statement.
<br>
# 2. Set a variable to a boolean. Create an if-else-statement that checks if a boolean is False. Print a unique message for the if-statment and the else-statement.
<br>
# 3. Set a variable to an input function that asks for the user's name. Create an if-else-statement that checks if the user's name is equal to your name(make this a string). Print a unique message for the if-statment and the else-statement.
<br>
# 4. Set a variable to a string and another variable to an integer. Create an if-else-statement that checks if a string is equal to "Banana" and check if the integer is equal to 5. Implement the following keyword using the 'and' keyword, then implement the following with nested if-conditions.
<br>
# E2. Set a variable to a boolean expression using the 'not' keyword that evaluates to True. Print the variable
<br>
# E2. Solution
{% call code_block()%}
<pre><code class = "lang-python">
exp = not (5 != 5)
print(exp)
</pre></code>
{% endcall %}


# 5. Set a variable to a boolean expression using the 'not' keyword that evaluates to False. Print the variable.
<br>
# 6. Set a variable to a boolean expression using the 'and' keyword that evaluates to True. Print the variable.
<br>
# 7. Set a variable to a boolean expression using the 'and' keyword that evaluates to False. Print the variable.
<br>
# 8. Set a variable to a boolean expression using the 'or' keyword that evaluates to True. Print the variable.
<br>
# 9. Set a variable to a boolean expression using the 'or' keyword that evaluates to False. Print the variable.
<br>

<p>
# 10. You and your date are trying to get a table at a restaurant. <br>
The variable “you” is the stylishness of your clothes, in the range 0..10, and the variable “date” is the stylishness of your date’s clothes. <br>
The result getting the table is an string value with "no", "yes", "maybe" <br>
If either of you is very stylish, 8 or more, then the result is "yes".  <br>
With the exception that if either of you has a style of 2 or less, then the result is "no". <br>
Otherwise the result is "maybe". <br>
Examples: <br>
date = 5, you = 10 -> print("yes") <br>
date = 5, you = 2 -> print("no") <br>
date = 5, you = 5 -> print("maybe") <br>

You will need to use nested-if conditions and else statements to check the various conditions of you and your date. <br>
BONUS: set the variables 'date' and 'you' to input functions that are type casted into integers.
</p>
{% endcall %}

{% call document_modal(doc_id="ans_py_di_3", title="Conditionals Homework Answers", hidden_val="ans_py_hv_3", read="ans_py_r_3", size="lg") %}
{% call code_block()%}
<pre><code class = "lang-python">
# 1. Solution
word = "Banana"
if word == "Banana":
    print("The word is " + word)
else:
    print(word + " is not equal to Banana")
</pre></code>
{% endcall %}

{% call code_block()%}
<pre><code class = "lang-python">
# 2. Solution:
b_exp = True
if b_exp:
    print("The variable is True")
else:
    print(""The variable is not True"")
</pre></code>
{% endcall %}

{% call code_block()%}
<pre><code class = "lang-python">
# 3. Solution:
user_inp = input("What is your name? ")
if user_inp == "Akshay":
    print("The name of the user is Akshay")
else:
    print("The name of the user is not Akshay")
</pre></code>
{% endcall %}

{% call code_block()%}
<pre><code class = "lang-python">
# 4. Solution Pt. A:
word = "Banana"
num = 5
if word == "Banana":
    if num == 5:
        print("word and num equals Banana and 5")
    else:
        print("num is not equal to 5")
else:
    print("word is not equal to banana")

# 4. Solution Pt. B
word = "Banana"
num = 5
if word == "Banana" and num == 5:
    print("word and num equals Banana and 5")
else:
    print("word or num does not equal Banana and 5")
</pre></code>
{% endcall %}

{% call code_block()%}
<pre><code class = "lang-python">
# 5. Solution
exp = not (5==5)
print(exp)
</pre></code>
{% endcall %}

{% call code_block()%}
<pre><code class = "lang-python">
# 6. Solution
exp = (2&lt;3) and (5==5)
print(exp)
</pre></code>
{% endcall %}

{% call code_block()%}
<pre><code class = "lang-python">
# 7. Solution
exp = True and ("a" == "b")
print(exp)
</pre></code>
{% endcall %}

{% call code_block()%}
<pre><code class = "lang-python">
# 8. Solution
exp = True or ("a" == "b")
print(exp)
</pre></code>
{% endcall %}

{% call code_block()%}
<pre><code class = "lang-python">
# 9. Solution
exp = False or ("a" == "b")
print(exp)
</pre></code>
{% endcall %}

{% call code_block()%}
<pre><code class = "lang-python">
#10.
date = 5
you = 10

if (date < 8 or you < 8) and (date <= 2 or you <= 2):
    print("no")
else:
    if date >= 8 or you >= 8:
        print("yes")
    else:
        print("maybe")
</pre></code>
{% endcall %}
{% endcall %}

{% call document_modal(doc_id="hw_py_di_4", title="Lists, Tuples, & Sets Homework", hidden_val="hw_py_hv_4", read="hw_py_r_4", size="lg") %}
1. Set a variable to an empty list
<br>
2. Set a variable to a list with elements of different types(strings, integers, floats, booleans, etc). Print this variable.
<br>
3. Use the list created in Question 2 and access the first element using subscripting. Print this value.
<br>
4. Use the list created in Question 2 and access the last element using subscripting. Print this value.
<br>
5. Use the list created in Question 2 and access some element using subscripting. Print this value.
<br>
6. Set a variable to an empty tuple.
<br>
7. Set a variable to a tuple with elements of different types(strings, integers, floats, booleans, etc). Print this variable.
<br>
8. Use the tuple created in Question 7 and access the first element using subscripting. Print this value.
<br>
9. Use the tuple created in Question 7 and access the last element using subscripting. Print this value.
<br>
10. Use the tuple created in Question 7 and access some element using subscripting. Print this value.
<br>
11. Set a variable to an empty set
<br>
12. Set a variable to a tuple with elements of different types(strings, integers, floats, booleans, etc). Print this variable.
<br>
13. Set a variable to a list with elements of different types(strings, integers, floats, booleans, etc), include atleast two values with similar values and types.
<br>
14. Set a variable to a tuple by type-casting the list from Question 13. Print this variable.
<br>
15. Set a variable to a set by type-casting the list from Question 13. Print this variable.
<br>
16. Print the len of the list in Question 13 by using the 'len()' function
<br>
17. Remove the last value of the list in Question 13 using one of the list functions. Hint: uses position.
<br>
18. Remove the any value between the first and last (not including first and last) of the list in Question 13 using one of the list functions. Hint: uses positioin.
<br>
19. Add a value to the list in Question 13 using the append function.
<br>
20. Remove a value in the list from Question 13 by using the 'pop()' function, set this value to a variable. Add this value back onto the list using the 'append()' function.
<br>
21. Remove an element in the list based on its value using a list function. Hint: uses value.
<br>
22. Set a variable with a non-empty string.
<br>
23. Use the variable in question 22 to find the first character in the variable.
<br>
24. Use the variable in question 22 to find the last character in the variable.
<br>
25. Use the variable in question 22 to find the character in the middle of the string.
<br>
{% endcall %}


{% call document_modal(doc_id="ans_py_di_4", title="Lists, Tuples, & Sets Homework Answers", hidden_val="ans_py_hv_4", read="ans_py_r_4", size="lg") %}
{% call code_block()%}
<pre><code class = "lang-python">
#1. Solution
empty_list = []

#2. Solution
unique_list = [1, 3.0, "Banana", False]
print(unique_list)

#3. Solution
print(unique_list[0])

#4. Solution
print(unique_list[-1])

#5. Solution
print(unique_list[2]) # As long the value is less than the length of the list it work

#6. Solution
empty_tuple = ()

#7. Solution
unique_tuple = (1, 3.0, "Banana", False)
print(unique_tuple)

#8. Solution
print(unique_tuple[0])

#9. Solution
print(unique_tuple[-1])

#10. Solution
print(unique_tuple[2]) # As long the value is less than the length of the tuple it work

#11. Solution
empty_set = {}

#12. Solution
unique_set = {1, 3.0, "Banana", False}
print(unique_set)

#13. Solution
conv_list = [1, 3.0, "Banana", False, "Banana"]

#14. Solution
conv_tuple = tuple(conv_list)
print(conv_tuple)

#15. Solution
conv_set = set(conv_set)
print(conv_set)

#16. Solution
print(len(conv_list))

#17. Solution
conv_list.pop()
print(conv_list)

#18. Solution
conv_list.pop(1)
print(conv_list)

#19. Solution
conv_list.append("Chicken")

#20. Solution
last_val = conv_list.pop(0)
conv_list.append(last_val)
print(conv_list)

#21. Solution
conv_list.remove(3.0)
print(conv_list)

#22. Solution
animal = "Chicken"

#23. Solution
print(animal[0])

#24. Solution
print(animal[-1])

#25. Solution
print(animal[2])
</pre></code>
{% endcall %}
{% endcall %}



{% call document_modal(doc_id="hw_py_di_5", title="Loops Homework", hidden_val="hw_py_hv_5", read="hw_py_r_5", size="lg") %}
<p>
1. Create a for loop that loops through a range of numbers from 0 to 10 and prints each number.
<br>
2. Create a for loop that loops through the characters of a string and prints each character.
<br>
3. Create a for loop that loops through the elements of a list and prints each element.
<br>
4. Create a while loop that will run only 10 times. Hint: use a counter variable and increment it
<br>
5. Create a for loop that loops through a range of number from 0 to 100 and prints "Wazzah!" every time it encounters a number divisible by 5.
<br>
6. Create a loop that continues to loop until it encounters an even number. You can use a for or while loop for this question and you will need to use the 'break' keyword.
<br>
7. Create a loop that prints only even numbers in its range. You will need to use an if condition for this question. You can do the following without the 'continue' keyword, but for the sake of practice use it.
<br>
</p>
{% endcall%}

{% call document_modal(doc_id="ans_py_di_5", title="Loops Homework Answers", hidden_val="ans_py_hv_5", read="ans_py_r_5", size="lg") %}
{% call code_block()%}
<pre>
  <code class = "lang-python">
# 1. Solution
for n in range(0, 11):
    print(n)

# 2. Solution
word = "Banana"
for letter in word:
    print(letter)

# 3. Solution
for val in [1, 2.0, "Banana", False]):
    print(val)

# 4. Solution
counter = 0
while counter < 10:
    print(counter)
    counter +=1

# 5. Solution
for num in range(0, 101):
    if num % 5 == 0:
        print("Wazzah!")

# 6. Solution
for n in range(0, 11):
    if n % 2 == 0:
        break

# 7. Solution
for n in range(0, 11):
    if n % 2 == 1:
        continue
    print(n)
</pre></code>
{% endcall %}
{% endcall%}
{% endmacro%}